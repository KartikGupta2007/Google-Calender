"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/event-renderer.tsx":
/*!***************************************!*\
  !*** ./components/event-renderer.tsx ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventRenderer: function() { return /* binding */ EventRenderer; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _lib_store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/store */ \"(app-pages-browser)/./lib/store.ts\");\n/* harmony import */ var dayjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! dayjs */ \"(app-pages-browser)/./node_modules/dayjs/dayjs.min.js\");\n/* harmony import */ var dayjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(dayjs__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var dayjs_plugin_isSameOrBefore__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! dayjs/plugin/isSameOrBefore */ \"(app-pages-browser)/./node_modules/dayjs/plugin/isSameOrBefore.js\");\n/* harmony import */ var dayjs_plugin_isSameOrBefore__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(dayjs_plugin_isSameOrBefore__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var dayjs_plugin_isSameOrAfter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! dayjs/plugin/isSameOrAfter */ \"(app-pages-browser)/./node_modules/dayjs/plugin/isSameOrAfter.js\");\n/* harmony import */ var dayjs_plugin_isSameOrAfter__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(dayjs_plugin_isSameOrAfter__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _resizable_event__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./resizable-event */ \"(app-pages-browser)/./components/resizable-event.tsx\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\ndayjs__WEBPACK_IMPORTED_MODULE_2___default().extend((dayjs_plugin_isSameOrBefore__WEBPACK_IMPORTED_MODULE_3___default()));\ndayjs__WEBPACK_IMPORTED_MODULE_2___default().extend((dayjs_plugin_isSameOrAfter__WEBPACK_IMPORTED_MODULE_4___default()));\nfunction EventRenderer(param) {\n    let { date, view, events, excludeAllDay = false } = param;\n    _s();\n    const { openEventSummary, updateEvent } = (0,_lib_store__WEBPACK_IMPORTED_MODULE_1__.useEventStore)();\n    // Calendar colors from styles.css - matching exact CSS variables\n    const calendarColors = [\n        {\n            bg: \"var(--cal-kartik)\",\n            color: \"white\"\n        },\n        {\n            bg: \"var(--cal-birthdays)\",\n            color: \"white\"\n        },\n        {\n            bg: \"var(--cal-family)\",\n            color: \"white\"\n        },\n        {\n            bg: \"var(--cal-tasks)\",\n            color: \"#131314\"\n        },\n        {\n            bg: \"var(--cal-holidays)\",\n            color: \"white\"\n        }\n    ];\n    // For day/week view, we need to filter events that START in this hour\n    if (view === \"week\" || view === \"day\") {\n        // Get ALL events for the day to calculate overlaps properly\n        let allDayEvents = events.filter((event)=>{\n            return event.date.format(\"DD-MM-YY\") === date.format(\"DD-MM-YY\");\n        });\n        // Exclude all-day events if requested\n        if (excludeAllDay) {\n            allDayEvents = allDayEvents.filter((event)=>{\n                const eventEnd = event.endDate || event.date.add(1, \"hour\");\n                const durationHours = eventEnd.diff(event.date, \"hour\", true);\n                const startsAtMidnight = event.date.hour() === 0 && event.date.minute() === 0;\n                // Exclude if it's an all-day event\n                return !(durationHours >= 20 || startsAtMidnight && durationHours >= 12);\n            });\n        }\n        // Calculate overlaps and assign columns to ALL events for the day\n        const eventsWithLayout = allDayEvents.map((event)=>{\n            const eventStart = event.date;\n            const eventEnd = event.endDate || event.date.add(1, \"hour\");\n            return {\n                event,\n                start: eventStart,\n                end: eventEnd,\n                column: 0,\n                totalColumns: 1,\n                isContained: false\n            };\n        });\n        // Sort events by start time, then by duration (longer events first)\n        eventsWithLayout.sort((a, b)=>{\n            const startDiff = a.start.valueOf() - b.start.valueOf();\n            if (startDiff !== 0) return startDiff;\n            return b.end.valueOf() - a.end.valueOf(); // Longer events first\n        });\n        // Mark contained events\n        eventsWithLayout.forEach((eventLayout)=>{\n            eventLayout.isContained = eventsWithLayout.some((e)=>{\n                if (e.event.id === eventLayout.event.id) return false;\n                return e.start.isSameOrBefore(eventLayout.start) && e.end.isSameOrAfter(eventLayout.end);\n            });\n        });\n        // Assign columns using a greedy algorithm\n        const columns = [];\n        eventsWithLayout.forEach((eventLayout)=>{\n            // Check if this event is completely contained within another event\n            const containerEvent = eventsWithLayout.find((e)=>{\n                if (e.event.id === eventLayout.event.id) return false;\n                // Check if eventLayout is completely within e\n                return e.start.isSameOrBefore(eventLayout.start) && e.end.isSameOrAfter(eventLayout.end);\n            });\n            if (containerEvent) {\n                // If contained, place it in the next column after the container\n                eventLayout.column = (containerEvent.column || 0) + 1;\n                // Add to appropriate column array\n                if (!columns[eventLayout.column]) {\n                    columns[eventLayout.column] = [];\n                }\n                columns[eventLayout.column].push(eventLayout);\n            } else {\n                // Find the first column where this event doesn't overlap with any existing event\n                let placed = false;\n                for(let i = 0; i < columns.length; i++){\n                    const columnEvents = columns[i];\n                    const hasOverlap = columnEvents.some((e)=>e.start.isBefore(eventLayout.end) && e.end.isAfter(eventLayout.start));\n                    if (!hasOverlap) {\n                        columns[i].push(eventLayout);\n                        eventLayout.column = i;\n                        placed = true;\n                        break;\n                    }\n                }\n                // If no suitable column found, create a new one\n                if (!placed) {\n                    columns.push([\n                        eventLayout\n                    ]);\n                    eventLayout.column = columns.length - 1;\n                }\n            }\n        });\n        // Set totalColumns for all events\n        const maxColumns = columns.length;\n        eventsWithLayout.forEach((eventLayout)=>{\n            // Find all events that overlap with this event\n            const overlappingEvents = eventsWithLayout.filter((e)=>e.event.id !== eventLayout.event.id && e.start.isBefore(eventLayout.end) && e.end.isAfter(eventLayout.start));\n            // Total columns is the max column index among overlapping events + 1\n            const maxColumn = Math.max(eventLayout.column, ...overlappingEvents.map((e)=>e.column));\n            eventLayout.totalColumns = maxColumn + 1;\n        });\n        const eventsWithColumns = eventsWithLayout;\n        // Filter to only events that START in this specific hour\n        const eventsStartingInThisHour = eventsWithColumns.filter((param)=>{\n            let { event } = param;\n            return event.date.format(\"DD-MM-YY HH\") === date.format(\"DD-MM-YY HH\");\n        });\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: eventsStartingInThisHour.map((param, index)=>{\n                let { event, start: eventStart, end: eventEnd, column, totalColumns } = param;\n                // Calculate duration in minutes\n                const durationMinutes = eventEnd.diff(eventStart, \"minute\");\n                const height = durationMinutes / 60 * 48; // 48px per hour\n                // Calculate offset from top of hour slot\n                const minutesFromHourStart = eventStart.minute();\n                const topOffset = minutesFromHourStart / 60 * 48;\n                // Calculate width and left position based on column\n                let leftPercent;\n                let widthPercent;\n                // Check if this event is contained within another\n                const isContainedEvent = eventsWithColumns.some((e)=>{\n                    if (e.event.id === event.id) return false;\n                    // Must be strictly contained: container starts at or before, ends at or after\n                    // AND they don't have identical time spans\n                    const startsAtOrBefore = e.start.isSameOrBefore(eventStart);\n                    const endsAtOrAfter = e.end.isSameOrAfter(eventEnd);\n                    const notIdentical = !(e.start.isSame(eventStart) && e.end.isSame(eventEnd));\n                    return startsAtOrBefore && endsAtOrAfter && notIdentical;\n                });\n                // Check if this event contains other events\n                const hasContainedEvents = eventsWithColumns.some((e)=>{\n                    if (e.event.id === event.id) return false;\n                    // This event must start at or before the other, and end at or after the other\n                    // AND they don't have identical time spans\n                    const startsAtOrBefore = eventStart.isSameOrBefore(e.start);\n                    const endsAtOrAfter = eventEnd.isSameOrAfter(e.end);\n                    const notIdentical = !(eventStart.isSame(e.start) && eventEnd.isSame(e.end));\n                    return startsAtOrBefore && endsAtOrAfter && notIdentical;\n                });\n                if (isContainedEvent) {\n                    // Contained event: starts with 10% gap from left, extends to right edge\n                    leftPercent = 10;\n                    widthPercent = 90;\n                } else if (hasContainedEvents) {\n                    // Container event: full width\n                    leftPercent = 0;\n                    widthPercent = 100;\n                } else {\n                    // Regular overlapping events: equal split\n                    const columnWidth = 100 / totalColumns;\n                    leftPercent = column * columnWidth;\n                    widthPercent = columnWidth;\n                }\n                // Generate a stable color index from event ID or use index as fallback\n                let colorIndex = index % calendarColors.length;\n                if (event.id) {\n                    const numericId = parseInt(event.id);\n                    if (!isNaN(numericId)) {\n                        colorIndex = numericId % calendarColors.length;\n                    } else {\n                        // For non-numeric IDs (like Google Calendar IDs), use string hash\n                        let hash = 0;\n                        for(let i = 0; i < event.id.length; i++){\n                            hash = (hash << 5) - hash + event.id.charCodeAt(i);\n                            hash = hash & hash; // Convert to 32bit integer\n                        }\n                        colorIndex = Math.abs(hash) % calendarColors.length;\n                    }\n                }\n                const colors = calendarColors[colorIndex];\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_resizable_event__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                    event: event,\n                    eventStart: eventStart,\n                    eventEnd: eventEnd,\n                    height: height,\n                    topOffset: topOffset,\n                    leftPercent: leftPercent,\n                    widthPercent: widthPercent,\n                    colors: colors,\n                    zIndex: isContainedEvent ? 10 : 5,\n                    onClick: (e)=>{\n                        e.stopPropagation();\n                        openEventSummary(event);\n                    }\n                }, event.id, false, {\n                    fileName: \"/Users/kartikgupta/Downloads/Google-Calender/components/event-renderer.tsx\",\n                    lineNumber: 213,\n                    columnNumber: 13\n                }, this);\n            })\n        }, void 0, false);\n    }\n    // Month view - keep existing logic\n    const filteredEvents = events.filter((event)=>{\n        return event.date.format(\"DD-MM-YY\") === date.format(\"DD-MM-YY\");\n    });\n    // Display max 3 events\n    const displayEvents = filteredEvents.slice(0, 3);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: displayEvents.map((event, index)=>{\n            // Generate a stable color index from event ID or use index as fallback\n            let colorIndex = index % calendarColors.length;\n            if (event.id) {\n                const numericId = parseInt(event.id);\n                if (!isNaN(numericId)) {\n                    colorIndex = numericId % calendarColors.length;\n                } else {\n                    // For non-numeric IDs (like Google Calendar IDs), use string hash\n                    let hash = 0;\n                    for(let i = 0; i < event.id.length; i++){\n                        hash = (hash << 5) - hash + event.id.charCodeAt(i);\n                        hash = hash & hash; // Convert to 32bit integer\n                    }\n                    colorIndex = Math.abs(hash) % calendarColors.length;\n                }\n            }\n            const colors = calendarColors[colorIndex];\n            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                \"data-event-id\": event.id,\n                draggable: true,\n                onDragStart: (e)=>{\n                    e.stopPropagation();\n                    e.dataTransfer.effectAllowed = \"move\";\n                    e.dataTransfer.setData(\"application/json\", JSON.stringify({\n                        eventId: event.id,\n                        eventDate: event.date.format(\"YYYY-MM-DD HH:mm:ss\")\n                    }));\n                    e.currentTarget.style.opacity = \"0.5\";\n                },\n                onDragEnd: (e)=>{\n                    e.currentTarget.style.opacity = \"1\";\n                },\n                onClick: (e)=>{\n                    e.stopPropagation();\n                    openEventSummary(event);\n                },\n                className: \"cursor-pointer transition-all\",\n                style: {\n                    fontSize: \"12px\",\n                    padding: \"2px 6px\",\n                    borderRadius: \"4px\",\n                    whiteSpace: \"nowrap\",\n                    overflow: \"hidden\",\n                    textOverflow: \"ellipsis\",\n                    fontWeight: 500,\n                    lineHeight: 1.4,\n                    background: colors.bg,\n                    color: colors.color\n                },\n                onMouseEnter: (e)=>{\n                    e.currentTarget.style.opacity = \"0.8\";\n                },\n                onMouseLeave: (e)=>{\n                    e.currentTarget.style.opacity = \"1\";\n                },\n                children: event.title\n            }, event.id, false, {\n                fileName: \"/Users/kartikgupta/Downloads/Google-Calender/components/event-renderer.tsx\",\n                lineNumber: 265,\n                columnNumber: 11\n            }, this);\n        })\n    }, void 0, false);\n}\n_s(EventRenderer, \"yRKFIAESwGl8pRA8+q/h6/0co4k=\", false, function() {\n    return [\n        _lib_store__WEBPACK_IMPORTED_MODULE_1__.useEventStore\n    ];\n});\n_c = EventRenderer;\nvar _c;\n$RefreshReg$(_c, \"EventRenderer\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvZXZlbnQtcmVuZGVyZXIudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQytEO0FBRXJDO0FBQytCO0FBQ0Y7QUFDN0I7QUFDcUI7QUFFL0NDLG1EQUFZLENBQUNDLG9FQUFjQTtBQUMzQkQsbURBQVksQ0FBQ0UsbUVBQWFBO0FBU25CLFNBQVNJLGNBQWMsS0FBaUU7UUFBakUsRUFBRUMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsZ0JBQWdCLEtBQUssRUFBc0IsR0FBakU7O0lBQzVCLE1BQU0sRUFBRUMsZ0JBQWdCLEVBQUVDLFdBQVcsRUFBRSxHQUFHYix5REFBYUE7SUFFdkQsaUVBQWlFO0lBQ2pFLE1BQU1jLGlCQUFpQjtRQUNyQjtZQUFFQyxJQUFJO1lBQXFCQyxPQUFPO1FBQVE7UUFDMUM7WUFBRUQsSUFBSTtZQUF3QkMsT0FBTztRQUFRO1FBQzdDO1lBQUVELElBQUk7WUFBcUJDLE9BQU87UUFBUTtRQUMxQztZQUFFRCxJQUFJO1lBQW9CQyxPQUFPO1FBQVU7UUFDM0M7WUFBRUQsSUFBSTtZQUF1QkMsT0FBTztRQUFRO0tBQzdDO0lBRUQsc0VBQXNFO0lBQ3RFLElBQUlQLFNBQVMsVUFBVUEsU0FBUyxPQUFPO1FBQ3JDLDREQUE0RDtRQUM1RCxJQUFJUSxlQUFlUCxPQUFPUSxNQUFNLENBQUMsQ0FBQ0M7WUFDaEMsT0FBT0EsTUFBTVgsSUFBSSxDQUFDWSxNQUFNLENBQUMsZ0JBQWdCWixLQUFLWSxNQUFNLENBQUM7UUFDdkQ7UUFFQSxzQ0FBc0M7UUFDdEMsSUFBSVQsZUFBZTtZQUNqQk0sZUFBZUEsYUFBYUMsTUFBTSxDQUFDLENBQUNDO2dCQUNsQyxNQUFNRSxXQUFXRixNQUFNRyxPQUFPLElBQUlILE1BQU1YLElBQUksQ0FBQ2UsR0FBRyxDQUFDLEdBQUc7Z0JBQ3BELE1BQU1DLGdCQUFnQkgsU0FBU0ksSUFBSSxDQUFDTixNQUFNWCxJQUFJLEVBQUUsUUFB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QTBDbkI7O0FBR047R0FuU2dCdkM7O1FBQzRCUCxxREFBYUE7OztLQUR6Q08iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9ldmVudC1yZW5kZXJlci50c3g/Mjk2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IENhbGVuZGFyRXZlbnRUeXBlLCB1c2VFdmVudFN0b3JlIH0gZnJvbSBcIkAvbGliL3N0b3JlXCI7XG5cbmltcG9ydCBkYXlqcyBmcm9tIFwiZGF5anNcIjtcbmltcG9ydCBpc1NhbWVPckJlZm9yZSBmcm9tIFwiZGF5anMvcGx1Z2luL2lzU2FtZU9yQmVmb3JlXCI7XG5pbXBvcnQgaXNTYW1lT3JBZnRlciBmcm9tIFwiZGF5anMvcGx1Z2luL2lzU2FtZU9yQWZ0ZXJcIjtcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBSZXNpemFibGVFdmVudCBmcm9tIFwiLi9yZXNpemFibGUtZXZlbnRcIjtcblxuZGF5anMuZXh0ZW5kKGlzU2FtZU9yQmVmb3JlKTtcbmRheWpzLmV4dGVuZChpc1NhbWVPckFmdGVyKTtcblxudHlwZSBFdmVudFJlbmRlcmVyUHJvcHMgPSB7XG4gIGRhdGU6IGRheWpzLkRheWpzO1xuICB2aWV3OiBcIm1vbnRoXCIgfCBcIndlZWtcIiB8IFwiZGF5XCI7XG4gIGV2ZW50czogQ2FsZW5kYXJFdmVudFR5cGVbXTtcbiAgZXhjbHVkZUFsbERheT86IGJvb2xlYW47XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gRXZlbnRSZW5kZXJlcih7IGRhdGUsIHZpZXcsIGV2ZW50cywgZXhjbHVkZUFsbERheSA9IGZhbHNlIH06IEV2ZW50UmVuZGVyZXJQcm9wcykge1xuICBjb25zdCB7IG9wZW5FdmVudFN1bW1hcnksIHVwZGF0ZUV2ZW50IH0gPSB1c2VFdmVudFN0b3JlKCk7XG5cbiAgLy8gQ2FsZW5kYXIgY29sb3JzIGZyb20gc3R5bGVzLmNzcyAtIG1hdGNoaW5nIGV4YWN0IENTUyB2YXJpYWJsZXNcbiAgY29uc3QgY2FsZW5kYXJDb2xvcnMgPSBbXG4gICAgeyBiZzogJ3ZhcigtLWNhbC1rYXJ0aWspJywgY29sb3I6ICd3aGl0ZScgfSwgICAgICAvLyAjMDM5QkU1IC0gS2FydGlrXG4gICAgeyBiZzogJ3ZhcigtLWNhbC1iaXJ0aGRheXMpJywgY29sb3I6ICd3aGl0ZScgfSwgICAvLyAjMEI4MDQzIC0gQmlydGhkYXlzXG4gICAgeyBiZzogJ3ZhcigtLWNhbC1mYW1pbHkpJywgY29sb3I6ICd3aGl0ZScgfSwgICAgICAvLyAjNzk4NkNCIC0gRmFtaWx5XG4gICAgeyBiZzogJ3ZhcigtLWNhbC10YXNrcyknLCBjb2xvcjogJyMxMzEzMTQnIH0sICAgICAvLyAjRjZCRjI2IC0gVGFza3NcbiAgICB7IGJnOiAndmFyKC0tY2FsLWhvbGlkYXlzKScsIGNvbG9yOiAnd2hpdGUnIH0sICAgIC8vICNFNjdDNzMgLSBIb2xpZGF5c1xuICBdO1xuXG4gIC8vIEZvciBkYXkvd2VlayB2aWV3LCB3ZSBuZWVkIHRvIGZpbHRlciBldmVudHMgdGhhdCBTVEFSVCBpbiB0aGlzIGhvdXJcbiAgaWYgKHZpZXcgPT09IFwid2Vla1wiIHx8IHZpZXcgPT09IFwiZGF5XCIpIHtcbiAgICAvLyBHZXQgQUxMIGV2ZW50cyBmb3IgdGhlIGRheSB0byBjYWxjdWxhdGUgb3ZlcmxhcHMgcHJvcGVybHlcbiAgICBsZXQgYWxsRGF5RXZlbnRzID0gZXZlbnRzLmZpbHRlcigoZXZlbnQ6IENhbGVuZGFyRXZlbnRUeXBlKSA9PiB7XG4gICAgICByZXR1cm4gZXZlbnQuZGF0ZS5mb3JtYXQoXCJERC1NTS1ZWVwiKSA9PT0gZGF0ZS5mb3JtYXQoXCJERC1NTS1ZWVwiKTtcbiAgICB9KTtcblxuICAgIC8vIEV4Y2x1ZGUgYWxsLWRheSBldmVudHMgaWYgcmVxdWVzdGVkXG4gICAgaWYgKGV4Y2x1ZGVBbGxEYXkpIHtcbiAgICAgIGFsbERheUV2ZW50cyA9IGFsbERheUV2ZW50cy5maWx0ZXIoKGV2ZW50OiBDYWxlbmRhckV2ZW50VHlwZSkgPT4ge1xuICAgICAgICBjb25zdCBldmVudEVuZCA9IGV2ZW50LmVuZERhdGUgfHwgZXZlbnQuZGF0ZS5hZGQoMSwgJ2hvdXInKTtcbiAgICAgICAgY29uc3QgZHVyYXRpb25Ib3VycyA9IGV2ZW50RW5kLmRpZmYoZXZlbnQuZGF0ZSwgJ2hvdXInLCB0cnVlKTtcbiAgICAgICAgY29uc3Qgc3RhcnRzQXRNaWRuaWdodCA9IGV2ZW50LmRhdGUuaG91cigpID09PSAwICYmIGV2ZW50LmRhdGUubWludXRlKCkgPT09IDA7XG5cbiAgICAgICAgLy8gRXhjbHVkZSBpZiBpdCdzIGFuIGFsbC1kYXkgZXZlbnRcbiAgICAgICAgcmV0dXJuICEoZHVyYXRpb25Ib3VycyA+PSAyMCB8fCAoc3RhcnRzQXRNaWRuaWdodCAmJiBkdXJhdGlvbkhvdXJzID49IDEyKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgb3ZlcmxhcHMgYW5kIGFzc2lnbiBjb2x1bW5zIHRvIEFMTCBldmVudHMgZm9yIHRoZSBkYXlcbiAgICBjb25zdCBldmVudHNXaXRoTGF5b3V0ID0gYWxsRGF5RXZlbnRzLm1hcChldmVudCA9PiB7XG4gICAgICBjb25zdCBldmVudFN0YXJ0ID0gZXZlbnQuZGF0ZTtcbiAgICAgIGNvbnN0IGV2ZW50RW5kID0gZXZlbnQuZW5kRGF0ZSB8fCBldmVudC5kYXRlLmFkZCgxLCAnaG91cicpO1xuICAgICAgcmV0dXJuIHsgZXZlbnQsIHN0YXJ0OiBldmVudFN0YXJ0LCBlbmQ6IGV2ZW50RW5kLCBjb2x1bW46IDAsIHRvdGFsQ29sdW1uczogMSwgaXNDb250YWluZWQ6IGZhbHNlIH07XG4gICAgfSk7XG5cbiAgICAvLyBTb3J0IGV2ZW50cyBieSBzdGFydCB0aW1lLCB0aGVuIGJ5IGR1cmF0aW9uIChsb25nZXIgZXZlbnRzIGZpcnN0KVxuICAgIGV2ZW50c1dpdGhMYXlvdXQuc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3Qgc3RhcnREaWZmID0gYS5zdGFydC52YWx1ZU9mKCkgLSBiLnN0YXJ0LnZhbHVlT2YoKTtcbiAgICAgIGlmIChzdGFydERpZmYgIT09IDApIHJldHVybiBzdGFydERpZmY7XG4gICAgICByZXR1cm4gYi5lbmQudmFsdWVPZigpIC0gYS5lbmQudmFsdWVPZigpOyAvLyBMb25nZXIgZXZlbnRzIGZpcnN0XG4gICAgfSk7XG5cbiAgICAvLyBNYXJrIGNvbnRhaW5lZCBldmVudHNcbiAgICBldmVudHNXaXRoTGF5b3V0LmZvckVhY2goZXZlbnRMYXlvdXQgPT4ge1xuICAgICAgZXZlbnRMYXlvdXQuaXNDb250YWluZWQgPSBldmVudHNXaXRoTGF5b3V0LnNvbWUoZSA9PiB7XG4gICAgICAgIGlmIChlLmV2ZW50LmlkID09PSBldmVudExheW91dC5ldmVudC5pZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gZS5zdGFydC5pc1NhbWVPckJlZm9yZShldmVudExheW91dC5zdGFydCkgJiYgZS5lbmQuaXNTYW1lT3JBZnRlcihldmVudExheW91dC5lbmQpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBBc3NpZ24gY29sdW1ucyB1c2luZyBhIGdyZWVkeSBhbGdvcml0aG1cbiAgICBjb25zdCBjb2x1bW5zOiB0eXBlb2YgZXZlbnRzV2l0aExheW91dFtdW10gPSBbXTtcblxuICAgIGV2ZW50c1dpdGhMYXlvdXQuZm9yRWFjaChldmVudExheW91dCA9PiB7XG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGV2ZW50IGlzIGNvbXBsZXRlbHkgY29udGFpbmVkIHdpdGhpbiBhbm90aGVyIGV2ZW50XG4gICAgICBjb25zdCBjb250YWluZXJFdmVudCA9IGV2ZW50c1dpdGhMYXlvdXQuZmluZChlID0+IHtcbiAgICAgICAgaWYgKGUuZXZlbnQuaWQgPT09IGV2ZW50TGF5b3V0LmV2ZW50LmlkKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIENoZWNrIGlmIGV2ZW50TGF5b3V0IGlzIGNvbXBsZXRlbHkgd2l0aGluIGVcbiAgICAgICAgcmV0dXJuIGUuc3RhcnQuaXNTYW1lT3JCZWZvcmUoZXZlbnRMYXlvdXQuc3RhcnQpICYmIGUuZW5kLmlzU2FtZU9yQWZ0ZXIoZXZlbnRMYXlvdXQuZW5kKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoY29udGFpbmVyRXZlbnQpIHtcbiAgICAgICAgLy8gSWYgY29udGFpbmVkLCBwbGFjZSBpdCBpbiB0aGUgbmV4dCBjb2x1bW4gYWZ0ZXIgdGhlIGNvbnRhaW5lclxuICAgICAgICBldmVudExheW91dC5jb2x1bW4gPSAoY29udGFpbmVyRXZlbnQuY29sdW1uIHx8IDApICsgMTtcbiAgICAgICAgLy8gQWRkIHRvIGFwcHJvcHJpYXRlIGNvbHVtbiBhcnJheVxuICAgICAgICBpZiAoIWNvbHVtbnNbZXZlbnRMYXlvdXQuY29sdW1uXSkge1xuICAgICAgICAgIGNvbHVtbnNbZXZlbnRMYXlvdXQuY29sdW1uXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbHVtbnNbZXZlbnRMYXlvdXQuY29sdW1uXS5wdXNoKGV2ZW50TGF5b3V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IGNvbHVtbiB3aGVyZSB0aGlzIGV2ZW50IGRvZXNuJ3Qgb3ZlcmxhcCB3aXRoIGFueSBleGlzdGluZyBldmVudFxuICAgICAgICBsZXQgcGxhY2VkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGNvbHVtbkV2ZW50cyA9IGNvbHVtbnNbaV07XG4gICAgICAgICAgY29uc3QgaGFzT3ZlcmxhcCA9IGNvbHVtbkV2ZW50cy5zb21lKGUgPT5cbiAgICAgICAgICAgIGUuc3RhcnQuaXNCZWZvcmUoZXZlbnRMYXlvdXQuZW5kKSAmJiBlLmVuZC5pc0FmdGVyKGV2ZW50TGF5b3V0LnN0YXJ0KVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAoIWhhc092ZXJsYXApIHtcbiAgICAgICAgICAgIGNvbHVtbnNbaV0ucHVzaChldmVudExheW91dCk7XG4gICAgICAgICAgICBldmVudExheW91dC5jb2x1bW4gPSBpO1xuICAgICAgICAgICAgcGxhY2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIG5vIHN1aXRhYmxlIGNvbHVtbiBmb3VuZCwgY3JlYXRlIGEgbmV3IG9uZVxuICAgICAgICBpZiAoIXBsYWNlZCkge1xuICAgICAgICAgIGNvbHVtbnMucHVzaChbZXZlbnRMYXlvdXRdKTtcbiAgICAgICAgICBldmVudExheW91dC5jb2x1bW4gPSBjb2x1bW5zLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNldCB0b3RhbENvbHVtbnMgZm9yIGFsbCBldmVudHNcbiAgICBjb25zdCBtYXhDb2x1bW5zID0gY29sdW1ucy5sZW5ndGg7XG4gICAgZXZlbnRzV2l0aExheW91dC5mb3JFYWNoKGV2ZW50TGF5b3V0ID0+IHtcbiAgICAgIC8vIEZpbmQgYWxsIGV2ZW50cyB0aGF0IG92ZXJsYXAgd2l0aCB0aGlzIGV2ZW50XG4gICAgICBjb25zdCBvdmVybGFwcGluZ0V2ZW50cyA9IGV2ZW50c1dpdGhMYXlvdXQuZmlsdGVyKGUgPT5cbiAgICAgICAgZS5ldmVudC5pZCAhPT0gZXZlbnRMYXlvdXQuZXZlbnQuaWQgJiZcbiAgICAgICAgZS5zdGFydC5pc0JlZm9yZShldmVudExheW91dC5lbmQpICYmXG4gICAgICAgIGUuZW5kLmlzQWZ0ZXIoZXZlbnRMYXlvdXQuc3RhcnQpXG4gICAgICApO1xuXG4gICAgICAvLyBUb3RhbCBjb2x1bW5zIGlzIHRoZSBtYXggY29sdW1uIGluZGV4IGFtb25nIG92ZXJsYXBwaW5nIGV2ZW50cyArIDFcbiAgICAgIGNvbnN0IG1heENvbHVtbiA9IE1hdGgubWF4KFxuICAgICAgICBldmVudExheW91dC5jb2x1bW4sXG4gICAgICAgIC4uLm92ZXJsYXBwaW5nRXZlbnRzLm1hcChlID0+IGUuY29sdW1uKVxuICAgICAgKTtcbiAgICAgIGV2ZW50TGF5b3V0LnRvdGFsQ29sdW1ucyA9IG1heENvbHVtbiArIDE7XG4gICAgfSk7XG5cbiAgICBjb25zdCBldmVudHNXaXRoQ29sdW1ucyA9IGV2ZW50c1dpdGhMYXlvdXQ7XG5cbiAgICAvLyBGaWx0ZXIgdG8gb25seSBldmVudHMgdGhhdCBTVEFSVCBpbiB0aGlzIHNwZWNpZmljIGhvdXJcbiAgICBjb25zdCBldmVudHNTdGFydGluZ0luVGhpc0hvdXIgPSBldmVudHNXaXRoQ29sdW1ucy5maWx0ZXIoKHsgZXZlbnQgfSkgPT4ge1xuICAgICAgcmV0dXJuIGV2ZW50LmRhdGUuZm9ybWF0KFwiREQtTU0tWVkgSEhcIikgPT09IGRhdGUuZm9ybWF0KFwiREQtTU0tWVkgSEhcIik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPD5cbiAgICAgICAge2V2ZW50c1N0YXJ0aW5nSW5UaGlzSG91ci5tYXAoKHsgZXZlbnQsIHN0YXJ0OiBldmVudFN0YXJ0LCBlbmQ6IGV2ZW50RW5kLCBjb2x1bW4sIHRvdGFsQ29sdW1ucyB9LCBpbmRleCkgPT4ge1xuICAgICAgICAgIC8vIENhbGN1bGF0ZSBkdXJhdGlvbiBpbiBtaW51dGVzXG4gICAgICAgICAgY29uc3QgZHVyYXRpb25NaW51dGVzID0gZXZlbnRFbmQuZGlmZihldmVudFN0YXJ0LCAnbWludXRlJyk7XG4gICAgICAgICAgY29uc3QgaGVpZ2h0ID0gKGR1cmF0aW9uTWludXRlcyAvIDYwKSAqIDQ4OyAvLyA0OHB4IHBlciBob3VyXG5cbiAgICAgICAgICAvLyBDYWxjdWxhdGUgb2Zmc2V0IGZyb20gdG9wIG9mIGhvdXIgc2xvdFxuICAgICAgICAgIGNvbnN0IG1pbnV0ZXNGcm9tSG91clN0YXJ0ID0gZXZlbnRTdGFydC5taW51dGUoKTtcbiAgICAgICAgICBjb25zdCB0b3BPZmZzZXQgPSAobWludXRlc0Zyb21Ib3VyU3RhcnQgLyA2MCkgKiA0ODtcblxuICAgICAgICAgIC8vIENhbGN1bGF0ZSB3aWR0aCBhbmQgbGVmdCBwb3NpdGlvbiBiYXNlZCBvbiBjb2x1bW5cbiAgICAgICAgICBsZXQgbGVmdFBlcmNlbnQ6IG51bWJlcjtcbiAgICAgICAgICBsZXQgd2lkdGhQZXJjZW50OiBudW1iZXI7XG5cbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGV2ZW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYW5vdGhlclxuICAgICAgICAgIGNvbnN0IGlzQ29udGFpbmVkRXZlbnQgPSBldmVudHNXaXRoQ29sdW1ucy5zb21lKGUgPT4ge1xuICAgICAgICAgICAgaWYgKGUuZXZlbnQuaWQgPT09IGV2ZW50LmlkKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAvLyBNdXN0IGJlIHN0cmljdGx5IGNvbnRhaW5lZDogY29udGFpbmVyIHN0YXJ0cyBhdCBvciBiZWZvcmUsIGVuZHMgYXQgb3IgYWZ0ZXJcbiAgICAgICAgICAgIC8vIEFORCB0aGV5IGRvbid0IGhhdmUgaWRlbnRpY2FsIHRpbWUgc3BhbnNcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0c0F0T3JCZWZvcmUgPSBlLnN0YXJ0LmlzU2FtZU9yQmVmb3JlKGV2ZW50U3RhcnQpO1xuICAgICAgICAgICAgY29uc3QgZW5kc0F0T3JBZnRlciA9IGUuZW5kLmlzU2FtZU9yQWZ0ZXIoZXZlbnRFbmQpO1xuICAgICAgICAgICAgY29uc3Qgbm90SWRlbnRpY2FsID0gIShlLnN0YXJ0LmlzU2FtZShldmVudFN0YXJ0KSAmJiBlLmVuZC5pc1NhbWUoZXZlbnRFbmQpKTtcbiAgICAgICAgICAgIHJldHVybiBzdGFydHNBdE9yQmVmb3JlICYmIGVuZHNBdE9yQWZ0ZXIgJiYgbm90SWRlbnRpY2FsO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBldmVudCBjb250YWlucyBvdGhlciBldmVudHNcbiAgICAgICAgICBjb25zdCBoYXNDb250YWluZWRFdmVudHMgPSBldmVudHNXaXRoQ29sdW1ucy5zb21lKGUgPT4ge1xuICAgICAgICAgICAgaWYgKGUuZXZlbnQuaWQgPT09IGV2ZW50LmlkKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAvLyBUaGlzIGV2ZW50IG11c3Qgc3RhcnQgYXQgb3IgYmVmb3JlIHRoZSBvdGhlciwgYW5kIGVuZCBhdCBvciBhZnRlciB0aGUgb3RoZXJcbiAgICAgICAgICAgIC8vIEFORCB0aGV5IGRvbid0IGhhdmUgaWRlbnRpY2FsIHRpbWUgc3BhbnNcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0c0F0T3JCZWZvcmUgPSBldmVudFN0YXJ0LmlzU2FtZU9yQmVmb3JlKGUuc3RhcnQpO1xuICAgICAgICAgICAgY29uc3QgZW5kc0F0T3JBZnRlciA9IGV2ZW50RW5kLmlzU2FtZU9yQWZ0ZXIoZS5lbmQpO1xuICAgICAgICAgICAgY29uc3Qgbm90SWRlbnRpY2FsID0gIShldmVudFN0YXJ0LmlzU2FtZShlLnN0YXJ0KSAmJiBldmVudEVuZC5pc1NhbWUoZS5lbmQpKTtcbiAgICAgICAgICAgIHJldHVybiBzdGFydHNBdE9yQmVmb3JlICYmIGVuZHNBdE9yQWZ0ZXIgJiYgbm90SWRlbnRpY2FsO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGlzQ29udGFpbmVkRXZlbnQpIHtcbiAgICAgICAgICAgIC8vIENvbnRhaW5lZCBldmVudDogc3RhcnRzIHdpdGggMTAlIGdhcCBmcm9tIGxlZnQsIGV4dGVuZHMgdG8gcmlnaHQgZWRnZVxuICAgICAgICAgICAgbGVmdFBlcmNlbnQgPSAxMDtcbiAgICAgICAgICAgIHdpZHRoUGVyY2VudCA9IDkwO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ29udGFpbmVkRXZlbnRzKSB7XG4gICAgICAgICAgICAvLyBDb250YWluZXIgZXZlbnQ6IGZ1bGwgd2lkdGhcbiAgICAgICAgICAgIGxlZnRQZXJjZW50ID0gMDtcbiAgICAgICAgICAgIHdpZHRoUGVyY2VudCA9IDEwMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUmVndWxhciBvdmVybGFwcGluZyBldmVudHM6IGVxdWFsIHNwbGl0XG4gICAgICAgICAgICBjb25zdCBjb2x1bW5XaWR0aCA9IDEwMCAvIHRvdGFsQ29sdW1ucztcbiAgICAgICAgICAgIGxlZnRQZXJjZW50ID0gY29sdW1uICogY29sdW1uV2lkdGg7XG4gICAgICAgICAgICB3aWR0aFBlcmNlbnQgPSBjb2x1bW5XaWR0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBHZW5lcmF0ZSBhIHN0YWJsZSBjb2xvciBpbmRleCBmcm9tIGV2ZW50IElEIG9yIHVzZSBpbmRleCBhcyBmYWxsYmFja1xuICAgICAgICAgIGxldCBjb2xvckluZGV4ID0gaW5kZXggJSBjYWxlbmRhckNvbG9ycy5sZW5ndGg7XG4gICAgICAgICAgaWYgKGV2ZW50LmlkKSB7XG4gICAgICAgICAgICBjb25zdCBudW1lcmljSWQgPSBwYXJzZUludChldmVudC5pZCk7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKG51bWVyaWNJZCkpIHtcbiAgICAgICAgICAgICAgY29sb3JJbmRleCA9IG51bWVyaWNJZCAlIGNhbGVuZGFyQ29sb3JzLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEZvciBub24tbnVtZXJpYyBJRHMgKGxpa2UgR29vZ2xlIENhbGVuZGFyIElEcyksIHVzZSBzdHJpbmcgaGFzaFxuICAgICAgICAgICAgICBsZXQgaGFzaCA9IDA7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnQuaWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBldmVudC5pZC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgICAgIGhhc2ggPSBoYXNoICYgaGFzaDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29sb3JJbmRleCA9IE1hdGguYWJzKGhhc2gpICUgY2FsZW5kYXJDb2xvcnMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjb2xvcnMgPSBjYWxlbmRhckNvbG9yc1tjb2xvckluZGV4XTtcblxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8UmVzaXphYmxlRXZlbnRcbiAgICAgICAgICAgICAga2V5PXtldmVudC5pZH1cbiAgICAgICAgICAgICAgZXZlbnQ9e2V2ZW50fVxuICAgICAgICAgICAgICBldmVudFN0YXJ0PXtldmVudFN0YXJ0fVxuICAgICAgICAgICAgICBldmVudEVuZD17ZXZlbnRFbmR9XG4gICAgICAgICAgICAgIGhlaWdodD17aGVpZ2h0fVxuICAgICAgICAgICAgICB0b3BPZmZzZXQ9e3RvcE9mZnNldH1cbiAgICAgICAgICAgICAgbGVmdFBlcmNlbnQ9e2xlZnRQZXJjZW50fVxuICAgICAgICAgICAgICB3aWR0aFBlcmNlbnQ9e3dpZHRoUGVyY2VudH1cbiAgICAgICAgICAgICAgY29sb3JzPXtjb2xvcnN9XG4gICAgICAgICAgICAgIHpJbmRleD17aXNDb250YWluZWRFdmVudCA/IDEwIDogNX1cbiAgICAgICAgICAgICAgb25DbGljaz17KGUpID0+IHtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIG9wZW5FdmVudFN1bW1hcnkoZXZlbnQpO1xuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApO1xuICAgICAgICB9KX1cbiAgICAgIDwvPlxuICAgICk7XG4gIH1cblxuICAvLyBNb250aCB2aWV3IC0ga2VlcCBleGlzdGluZyBsb2dpY1xuICBjb25zdCBmaWx0ZXJlZEV2ZW50cyA9IGV2ZW50cy5maWx0ZXIoKGV2ZW50OiBDYWxlbmRhckV2ZW50VHlwZSkgPT4ge1xuICAgIHJldHVybiBldmVudC5kYXRlLmZvcm1hdChcIkRELU1NLVlZXCIpID09PSBkYXRlLmZvcm1hdChcIkRELU1NLVlZXCIpO1xuICB9KTtcblxuICAvLyBEaXNwbGF5IG1heCAzIGV2ZW50c1xuICBjb25zdCBkaXNwbGF5RXZlbnRzID0gZmlsdGVyZWRFdmVudHMuc2xpY2UoMCwgMyk7XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAge2Rpc3BsYXlFdmVudHMubWFwKChldmVudCwgaW5kZXgpID0+IHtcbiAgICAgICAgLy8gR2VuZXJhdGUgYSBzdGFibGUgY29sb3IgaW5kZXggZnJvbSBldmVudCBJRCBvciB1c2UgaW5kZXggYXMgZmFsbGJhY2tcbiAgICAgICAgbGV0IGNvbG9ySW5kZXggPSBpbmRleCAlIGNhbGVuZGFyQ29sb3JzLmxlbmd0aDtcbiAgICAgICAgaWYgKGV2ZW50LmlkKSB7XG4gICAgICAgICAgY29uc3QgbnVtZXJpY0lkID0gcGFyc2VJbnQoZXZlbnQuaWQpO1xuICAgICAgICAgIGlmICghaXNOYU4obnVtZXJpY0lkKSkge1xuICAgICAgICAgICAgY29sb3JJbmRleCA9IG51bWVyaWNJZCAlIGNhbGVuZGFyQ29sb3JzLmxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRm9yIG5vbi1udW1lcmljIElEcyAobGlrZSBHb29nbGUgQ2FsZW5kYXIgSURzKSwgdXNlIHN0cmluZyBoYXNoXG4gICAgICAgICAgICBsZXQgaGFzaCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50LmlkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIGV2ZW50LmlkLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICAgIGhhc2ggPSBoYXNoICYgaGFzaDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2xvckluZGV4ID0gTWF0aC5hYnMoaGFzaCkgJSBjYWxlbmRhckNvbG9ycy5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbG9ycyA9IGNhbGVuZGFyQ29sb3JzW2NvbG9ySW5kZXhdO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAga2V5PXtldmVudC5pZH1cbiAgICAgICAgICAgIGRhdGEtZXZlbnQtaWQ9e2V2ZW50LmlkfVxuICAgICAgICAgICAgZHJhZ2dhYmxlPXt0cnVlfVxuICAgICAgICAgICAgb25EcmFnU3RhcnQ9eyhlKSA9PiB7XG4gICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgIGUuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSAnbW92ZSc7XG4gICAgICAgICAgICAgIGUuZGF0YVRyYW5zZmVyLnNldERhdGEoJ2FwcGxpY2F0aW9uL2pzb24nLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgZXZlbnRJZDogZXZlbnQuaWQsXG4gICAgICAgICAgICAgICAgZXZlbnREYXRlOiBldmVudC5kYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCBISDptbTpzcycpXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgZS5jdXJyZW50VGFyZ2V0LnN0eWxlLm9wYWNpdHkgPSAnMC41JztcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgICBvbkRyYWdFbmQ9eyhlKSA9PiB7XG4gICAgICAgICAgICAgIGUuY3VycmVudFRhcmdldC5zdHlsZS5vcGFjaXR5ID0gJzEnO1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIG9uQ2xpY2s9eyhlKSA9PiB7XG4gICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgIG9wZW5FdmVudFN1bW1hcnkoZXZlbnQpO1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImN1cnNvci1wb2ludGVyIHRyYW5zaXRpb24tYWxsXCJcbiAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgIGZvbnRTaXplOiAnMTJweCcsXG4gICAgICAgICAgICAgIHBhZGRpbmc6ICcycHggNnB4JyxcbiAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnNHB4JyxcbiAgICAgICAgICAgICAgd2hpdGVTcGFjZTogJ25vd3JhcCcsXG4gICAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgdGV4dE92ZXJmbG93OiAnZWxsaXBzaXMnLFxuICAgICAgICAgICAgICBmb250V2VpZ2h0OiA1MDAsXG4gICAgICAgICAgICAgIGxpbmVIZWlnaHQ6IDEuNCxcbiAgICAgICAgICAgICAgYmFja2dyb3VuZDogY29sb3JzLmJnLFxuICAgICAgICAgICAgICBjb2xvcjogY29sb3JzLmNvbG9yXG4gICAgICAgICAgICB9fVxuICAgICAgICAgICAgb25Nb3VzZUVudGVyPXsoZSkgPT4ge1xuICAgICAgICAgICAgICBlLmN1cnJlbnRUYXJnZXQuc3R5bGUub3BhY2l0eSA9ICcwLjgnO1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17KGUpID0+IHtcbiAgICAgICAgICAgICAgZS5jdXJyZW50VGFyZ2V0LnN0eWxlLm9wYWNpdHkgPSAnMSc7XG4gICAgICAgICAgICB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtldmVudC50aXRsZX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICAgIH0pfVxuICAgIDwvPlxuICApO1xufVxuIl0sIm5hbWVzIjpbInVzZUV2ZW50U3RvcmUiLCJkYXlqcyIsImlzU2FtZU9yQmVmb3JlIiwiaXNTYW1lT3JBZnRlciIsIlJlYWN0IiwiUmVzaXphYmxlRXZlbnQiLCJleHRlbmQiLCJFdmVudFJlbmRlcmVyIiwiZGF0ZSIsInZpZXciLCJldmVudHMiLCJleGNsdWRlQWxsRGF5Iiwib3BlbkV2ZW50U3VtbWFyeSIsInVwZGF0ZUV2ZW50IiwiY2FsZW5kYXJDb2xvcnMiLCJiZyIsImNvbG9yIiwiYWxsRGF5RXZlbnRzIiwiZmlsdGVyIiwiZXZlbnQiLCJmb3JtYXQiLCJldmVudEVuZCIsImVuZERhdGUiLCJhZGQiLCJkdXJhdGlvbkhvdXJzIiwiZGlmZiIsInN0YXJ0c0F0TWlkbmlnaHQiLCJob3VyIiwibWludXRlIiwiZXZlbnRzV2l0aExheW91dCIsIm1hcCIsImV2ZW50U3RhcnQiLCJzdGFydCIsImVuZCIsImNvbHVtbiIsInRvdGFsQ29sdW1ucyIsImlzQ29udGFpbmVkIiwic29ydCIsImEiLCJiIiwic3RhcnREaWZmIiwidmFsdWVPZiIsImZvckVhY2giLCJldmVudExheW91dCIsInNvbWUiLCJlIiwiaWQiLCJjb2x1bW5zIiwiY29udGFpbmVyRXZlbnQiLCJmaW5kIiwicHVzaCIsInBsYWNlZCIsImkiLCJsZW5ndGgiLCJjb2x1bW5FdmVudHMiLCJoYXNPdmVybGFwIiwiaXNCZWZvcmUiLCJpc0FmdGVyIiwibWF4Q29sdW1ucyIsIm92ZXJsYXBwaW5nRXZlbnRzIiwibWF4Q29sdW1uIiwiTWF0aCIsIm1heCIsImV2ZW50c1dpdGhDb2x1bW5zIiwiZXZlbnRzU3RhcnRpbmdJblRoaXNIb3VyIiwiaW5kZXgiLCJkdXJhdGlvbk1pbnV0ZXMiLCJoZWlnaHQiLCJtaW51dGVzRnJvbUhvdXJTdGFydCIsInRvcE9mZnNldCIsImxlZnRQZXJjZW50Iiwid2lkdGhQZXJjZW50IiwiaXNDb250YWluZWRFdmVudCIsInN0YXJ0c0F0T3JCZWZvcmUiLCJlbmRzQXRPckFmdGVyIiwibm90SWRlbnRpY2FsIiwiaXNTYW1lIiwiaGFzQ29udGFpbmVkRXZlbnRzIiwiY29sdW1uV2lkdGgiLCJjb2xvckluZGV4IiwibnVtZXJpY0lkIiwicGFyc2VJbnQiLCJpc05hTiIsImhhc2giLCJjaGFyQ29kZUF0IiwiYWJzIiwiY29sb3JzIiwiekluZGV4Iiwib25DbGljayIsInN0b3BQcm9wYWdhdGlvbiIsImZpbHRlcmVkRXZlbnRzIiwiZGlzcGxheUV2ZW50cyIsInNsaWNlIiwiZGl2IiwiZGF0YS1ldmVudC1pZCIsImRyYWdnYWJsZSIsIm9uRHJhZ1N0YXJ0IiwiZGF0YVRyYW5zZmVyIiwiZWZmZWN0QWxsb3dlZCIsInNldERhdGEiLCJKU09OIiwic3RyaW5naWZ5IiwiZXZlbnRJZCIsImV2ZW50RGF0ZSIsImN1cnJlbnRUYXJnZXQiLCJzdHlsZSIsIm9wYWNpdHkiLCJvbkRyYWdFbmQiLCJjbGFzc05hbWUiLCJmb250U2l6ZSIsInBhZGRpbmciLCJib3JkZXJSYWRpdXMiLCJ3aGl0ZVNwYWNlIiwib3ZlcmZsb3ciLCJ0ZXh0T3ZlcmZsb3ciLCJmb250V2VpZ2h0IiwibGluZUhlaWdodCIsImJhY2tncm91bmQiLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlTGVhdmUiLCJ0aXRsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/event-renderer.tsx\n"));

/***/ })

});