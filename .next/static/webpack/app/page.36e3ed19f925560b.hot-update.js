"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/event-renderer.tsx":
/*!***************************************!*\
  !*** ./components/event-renderer.tsx ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventRenderer: function() { return /* binding */ EventRenderer; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _lib_store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/store */ \"(app-pages-browser)/./lib/store.ts\");\n/* harmony import */ var dayjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! dayjs */ \"(app-pages-browser)/./node_modules/dayjs/dayjs.min.js\");\n/* harmony import */ var dayjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(dayjs__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var dayjs_plugin_isSameOrBefore__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! dayjs/plugin/isSameOrBefore */ \"(app-pages-browser)/./node_modules/dayjs/plugin/isSameOrBefore.js\");\n/* harmony import */ var dayjs_plugin_isSameOrBefore__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(dayjs_plugin_isSameOrBefore__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var dayjs_plugin_isSameOrAfter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! dayjs/plugin/isSameOrAfter */ \"(app-pages-browser)/./node_modules/dayjs/plugin/isSameOrAfter.js\");\n/* harmony import */ var dayjs_plugin_isSameOrAfter__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(dayjs_plugin_isSameOrAfter__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _resizable_event__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./resizable-event */ \"(app-pages-browser)/./components/resizable-event.tsx\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\ndayjs__WEBPACK_IMPORTED_MODULE_2___default().extend((dayjs_plugin_isSameOrBefore__WEBPACK_IMPORTED_MODULE_3___default()));\ndayjs__WEBPACK_IMPORTED_MODULE_2___default().extend((dayjs_plugin_isSameOrAfter__WEBPACK_IMPORTED_MODULE_4___default()));\nfunction EventRenderer(param) {\n    let { date, view, events, excludeAllDay = false } = param;\n    _s();\n    const { openEventSummary, updateEvent } = (0,_lib_store__WEBPACK_IMPORTED_MODULE_1__.useEventStore)();\n    // Calendar colors from styles.css - matching exact CSS variables\n    const calendarColors = [\n        {\n            bg: \"var(--cal-kartik)\",\n            color: \"white\"\n        },\n        {\n            bg: \"var(--cal-birthdays)\",\n            color: \"white\"\n        },\n        {\n            bg: \"var(--cal-family)\",\n            color: \"white\"\n        },\n        {\n            bg: \"var(--cal-tasks)\",\n            color: \"#131314\"\n        },\n        {\n            bg: \"var(--cal-holidays)\",\n            color: \"white\"\n        }\n    ];\n    // For day/week view, we need to filter events that START in this hour\n    if (view === \"week\" || view === \"day\") {\n        // Get ALL events for the day to calculate overlaps properly\n        let allDayEvents = events.filter((event)=>{\n            return event.date.format(\"DD-MM-YY\") === date.format(\"DD-MM-YY\");\n        });\n        // Exclude all-day events if requested\n        if (excludeAllDay) {\n            allDayEvents = allDayEvents.filter((event)=>{\n                const eventEnd = event.endDate || event.date.add(1, \"hour\");\n                const durationHours = eventEnd.diff(event.date, \"hour\", true);\n                const startsAtMidnight = event.date.hour() === 0 && event.date.minute() === 0;\n                // Exclude if it's an all-day event\n                return !(durationHours >= 20 || startsAtMidnight && durationHours >= 12);\n            });\n        }\n        // Calculate overlaps and assign columns to ALL events for the day\n        const eventsWithLayout = allDayEvents.map((event)=>{\n            const eventStart = event.date;\n            const eventEnd = event.endDate || event.date.add(1, \"hour\");\n            return {\n                event,\n                start: eventStart,\n                end: eventEnd,\n                column: 0,\n                totalColumns: 1,\n                isContained: false\n            };\n        });\n        // Sort events by start time, then by duration (longer events first)\n        eventsWithLayout.sort((a, b)=>{\n            const startDiff = a.start.valueOf() - b.start.valueOf();\n            if (startDiff !== 0) return startDiff;\n            return b.end.valueOf() - a.end.valueOf(); // Longer events first\n        });\n        // Mark contained events\n        eventsWithLayout.forEach((eventLayout)=>{\n            eventLayout.isContained = eventsWithLayout.some((e)=>{\n                if (e.event.id === eventLayout.event.id) return false;\n                return e.start.isSameOrBefore(eventLayout.start) && e.end.isSameOrAfter(eventLayout.end);\n            });\n        });\n        const columns = [];\n        eventsWithLayout.forEach((eventLayout)=>{\n            // Check if this event is completely contained within another event\n            const containerEvent = eventsWithLayout.find((e)=>{\n                if (e.event.id === eventLayout.event.id) return false;\n                // Check if eventLayout is completely within e\n                return e.start.isSameOrBefore(eventLayout.start) && e.end.isSameOrAfter(eventLayout.end);\n            });\n            if (containerEvent) {\n                // If contained, place it in the next column after the container\n                eventLayout.column = (containerEvent.column || 0) + 1;\n                // Add to appropriate column array\n                if (!columns[eventLayout.column]) {\n                    columns[eventLayout.column] = [];\n                }\n                columns[eventLayout.column].push(eventLayout);\n            } else {\n                // Find the first column where this event doesn't overlap with any existing event\n                let placed = false;\n                for(let i = 0; i < columns.length; i++){\n                    const columnEvents = columns[i];\n                    const hasOverlap = columnEvents.some((e)=>e.start.isBefore(eventLayout.end) && e.end.isAfter(eventLayout.start));\n                    if (!hasOverlap) {\n                        columns[i].push(eventLayout);\n                        eventLayout.column = i;\n                        placed = true;\n                        break;\n                    }\n                }\n                // If no suitable column found, create a new one\n                if (!placed) {\n                    columns.push([\n                        eventLayout\n                    ]);\n                    eventLayout.column = columns.length - 1;\n                }\n            }\n        });\n        // Set totalColumns for all events\n        const maxColumns = columns.length;\n        eventsWithLayout.forEach((eventLayout)=>{\n            // Find all events that overlap with this event\n            const overlappingEvents = eventsWithLayout.filter((e)=>e.event.id !== eventLayout.event.id && e.start.isBefore(eventLayout.end) && e.end.isAfter(eventLayout.start));\n            // Total columns is the max column index among overlapping events + 1\n            const maxColumn = Math.max(eventLayout.column, ...overlappingEvents.map((e)=>e.column));\n            eventLayout.totalColumns = maxColumn + 1;\n        });\n        const eventsWithColumns = eventsWithLayout;\n        // Filter to only events that START in this specific hour\n        const eventsStartingInThisHour = eventsWithColumns.filter((param)=>{\n            let { event } = param;\n            return event.date.format(\"DD-MM-YY HH\") === date.format(\"DD-MM-YY HH\");\n        });\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: eventsStartingInThisHour.map((param, index)=>{\n                let { event, start: eventStart, end: eventEnd, column, totalColumns } = param;\n                // Calculate duration in minutes\n                const durationMinutes = eventEnd.diff(eventStart, \"minute\");\n                const height = durationMinutes / 60 * 48; // 48px per hour\n                // Calculate offset from top of hour slot\n                const minutesFromHourStart = eventStart.minute();\n                const topOffset = minutesFromHourStart / 60 * 48;\n                // Calculate width and left position based on column\n                let leftPercent;\n                let widthPercent;\n                // Check if this event is contained within another\n                const isContainedEvent = eventsWithColumns.some((e)=>{\n                    if (e.event.id === event.id) return false;\n                    // Must be strictly contained: container starts at or before, ends at or after\n                    // AND they don't have identical time spans\n                    const startsAtOrBefore = e.start.isSameOrBefore(eventStart);\n                    const endsAtOrAfter = e.end.isSameOrAfter(eventEnd);\n                    const notIdentical = !(e.start.isSame(eventStart) && e.end.isSame(eventEnd));\n                    return startsAtOrBefore && endsAtOrAfter && notIdentical;\n                });\n                // Check if this event contains other events\n                const hasContainedEvents = eventsWithColumns.some((e)=>{\n                    if (e.event.id === event.id) return false;\n                    // This event must start at or before the other, and end at or after the other\n                    // AND they don't have identical time spans\n                    const startsAtOrBefore = eventStart.isSameOrBefore(e.start);\n                    const endsAtOrAfter = eventEnd.isSameOrAfter(e.end);\n                    const notIdentical = !(eventStart.isSame(e.start) && eventEnd.isSame(e.end));\n                    return startsAtOrBefore && endsAtOrAfter && notIdentical;\n                });\n                if (isContainedEvent) {\n                    // Contained event: starts with 10% gap from left, extends to right edge\n                    leftPercent = 10;\n                    widthPercent = 90;\n                } else if (hasContainedEvents) {\n                    // Container event: full width\n                    leftPercent = 0;\n                    widthPercent = 100;\n                } else {\n                    // Regular overlapping events: equal split\n                    const columnWidth = 100 / totalColumns;\n                    leftPercent = column * columnWidth;\n                    widthPercent = columnWidth;\n                }\n                // Generate a stable color index from event ID or use index as fallback\n                let colorIndex = index % calendarColors.length;\n                if (event.id) {\n                    const numericId = parseInt(event.id);\n                    if (!isNaN(numericId)) {\n                        colorIndex = numericId % calendarColors.length;\n                    } else {\n                        // For non-numeric IDs (like Google Calendar IDs), use string hash\n                        let hash = 0;\n                        for(let i = 0; i < event.id.length; i++){\n                            hash = (hash << 5) - hash + event.id.charCodeAt(i);\n                            hash = hash & hash; // Convert to 32bit integer\n                        }\n                        colorIndex = Math.abs(hash) % calendarColors.length;\n                    }\n                }\n                const colors = calendarColors[colorIndex];\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_resizable_event__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                    event: event,\n                    eventStart: eventStart,\n                    eventEnd: eventEnd,\n                    height: height,\n                    topOffset: topOffset,\n                    leftPercent: leftPercent,\n                    widthPercent: widthPercent,\n                    colors: colors,\n                    zIndex: isContainedEvent ? 10 : 5,\n                    onClick: (e)=>{\n                        e.stopPropagation();\n                        openEventSummary(event);\n                    }\n                }, event.id, false, {\n                    fileName: \"/Users/kartikgupta/Downloads/Google-Calender/components/event-renderer.tsx\",\n                    lineNumber: 221,\n                    columnNumber: 13\n                }, this);\n            })\n        }, void 0, false);\n    }\n    // Month view - keep existing logic\n    const filteredEvents = events.filter((event)=>{\n        return event.date.format(\"DD-MM-YY\") === date.format(\"DD-MM-YY\");\n    });\n    // Display max 3 events\n    const displayEvents = filteredEvents.slice(0, 3);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: displayEvents.map((event, index)=>{\n            // Generate a stable color index from event ID or use index as fallback\n            let colorIndex = index % calendarColors.length;\n            if (event.id) {\n                const numericId = parseInt(event.id);\n                if (!isNaN(numericId)) {\n                    colorIndex = numericId % calendarColors.length;\n                } else {\n                    // For non-numeric IDs (like Google Calendar IDs), use string hash\n                    let hash = 0;\n                    for(let i = 0; i < event.id.length; i++){\n                        hash = (hash << 5) - hash + event.id.charCodeAt(i);\n                        hash = hash & hash; // Convert to 32bit integer\n                    }\n                    colorIndex = Math.abs(hash) % calendarColors.length;\n                }\n            }\n            const colors = calendarColors[colorIndex];\n            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                \"data-event-id\": event.id,\n                draggable: true,\n                onDragStart: (e)=>{\n                    e.stopPropagation();\n                    e.dataTransfer.effectAllowed = \"move\";\n                    e.dataTransfer.setData(\"application/json\", JSON.stringify({\n                        eventId: event.id,\n                        eventDate: event.date.format(\"YYYY-MM-DD HH:mm:ss\")\n                    }));\n                    e.currentTarget.style.opacity = \"0.5\";\n                },\n                onDragEnd: (e)=>{\n                    e.currentTarget.style.opacity = \"1\";\n                },\n                onClick: (e)=>{\n                    e.stopPropagation();\n                    openEventSummary(event);\n                },\n                className: \"cursor-pointer transition-all\",\n                style: {\n                    fontSize: \"12px\",\n                    padding: \"2px 6px\",\n                    borderRadius: \"4px\",\n                    whiteSpace: \"nowrap\",\n                    overflow: \"hidden\",\n                    textOverflow: \"ellipsis\",\n                    fontWeight: 500,\n                    lineHeight: 1.4,\n                    background: colors.bg,\n                    color: colors.color\n                },\n                onMouseEnter: (e)=>{\n                    e.currentTarget.style.opacity = \"0.8\";\n                },\n                onMouseLeave: (e)=>{\n                    e.currentTarget.style.opacity = \"1\";\n                },\n                children: event.title\n            }, event.id, false, {\n                fileName: \"/Users/kartikgupta/Downloads/Google-Calender/components/event-renderer.tsx\",\n                lineNumber: 273,\n                columnNumber: 11\n            }, this);\n        })\n    }, void 0, false);\n}\n_s(EventRenderer, \"yRKFIAESwGl8pRA8+q/h6/0co4k=\", false, function() {\n    return [\n        _lib_store__WEBPACK_IMPORTED_MODULE_1__.useEventStore\n    ];\n});\n_c = EventRenderer;\nvar _c;\n$RefreshReg$(_c, \"EventRenderer\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvZXZlbnQtcmVuZGVyZXIudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQytEO0FBRXJDO0FBQytCO0FBQ0Y7QUFDN0I7QUFDcUI7QUFFL0NDLG1EQUFZLENBQUNDLG9FQUFjQTtBQUMzQkQsbURBQVksQ0FBQ0UsbUVBQWFBO0FBU25CLFNBQVNJLGNBQWMsS0FBaUU7UUFBakUsRUFBRUMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsZ0JBQWdCLEtBQUssRUFBc0IsR0FBakU7O0lBQzVCLE1BQU0sRUFBRUMsZ0JBQWdCLEVBQUVDLFdBQVcsRUFBRSxHQUFHYix5REFBYUE7SUFFdkQsaUVBQWlFO0lBQ2pFLE1BQU1jLGlCQUFpQjtRQUNyQjtZQUFFQyxJQUFJO1lBQXFCQyxPQUFPO1FBQVE7UUFDMUM7WUFBRUQsSUFBSTtZQUF3QkMsT0FBTztRQUFRO1FBQzdDO1lBQUVELElBQUk7WUFBcUJDLE9BQU87UUFBUTtRQUMxQztZQUFFRCxJQUFJO1lBQW9CQyxPQUFPO1FBQVU7UUFDM0M7WUFBRUQsSUFBSTtZQUF1QkMsT0FBTztRQUFRO0tBQzdDO0lBRUQsc0VBQXNFO0lBQ3RFLElBQUlQLFNBQVMsVUFBVUEsU0FBUyxPQUFPO1FBQ3JDLDREQUE0RDtRQUM1RCxJQUFJUSxlQUFlUCxPQUFPUSxNQUFNLENBQUMsQ0FBQ0M7WUFDaEMsT0FBT0EsTUFBTVgsSUFBSSxDQUFDWSxNQUFNLENBQUMsZ0JBQWdCWixLQUFLWSxNQUFNLENBQUM7UUFDdkQ7UUFFQSxzQ0FBc0M7UUFDdEMsSUFBSVQsZUFBZTtZQUNqQk0sZUFBZUEsYUFBYUMsTUFBTSxDQUFDLENBQUNDO2dCQUNsQyxNQUFNRSxXQUFXRixNQUFNRyxPQUFPLElBQUlILE1BQU1YLElBQUksQ0FBQ2UsR0FBRyxDQUFDLEdBQUc7Z0JBQ3BELE1BQU1DLGdCQUFnQkgsU0FBU0ksSUFBSSxDQUFDTixNQUFNWCxJQUFJLEVBQUUsUUFB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QTNTZ0J2Qzs7UUFDNEJQLHFEQUFhQTs7O0tBRHpDTyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL2V2ZW50LXJlbmRlcmVyLnRzeD8yOTY2Il0sInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHsgQ2FsZW5kYXJFdmVudFR5cGUsIHVzZUV2ZW50U3RvcmUgfSBmcm9tIFwiQC9saWIvc3RvcmVcIjtcblxuaW1wb3J0IGRheWpzIGZyb20gXCJkYXlqc1wiO1xuaW1wb3J0IGlzU2FtZU9yQmVmb3JlIGZyb20gXCJkYXlqcy9wbHVnaW4vaXNTYW1lT3JCZWZvcmVcIjtcbmltcG9ydCBpc1NhbWVPckFmdGVyIGZyb20gXCJkYXlqcy9wbHVnaW4vaXNTYW1lT3JBZnRlclwiO1xuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFJlc2l6YWJsZUV2ZW50IGZyb20gXCIuL3Jlc2l6YWJsZS1ldmVudFwiO1xuXG5kYXlqcy5leHRlbmQoaXNTYW1lT3JCZWZvcmUpO1xuZGF5anMuZXh0ZW5kKGlzU2FtZU9yQWZ0ZXIpO1xuXG50eXBlIEV2ZW50UmVuZGVyZXJQcm9wcyA9IHtcbiAgZGF0ZTogZGF5anMuRGF5anM7XG4gIHZpZXc6IFwibW9udGhcIiB8IFwid2Vla1wiIHwgXCJkYXlcIjtcbiAgZXZlbnRzOiBDYWxlbmRhckV2ZW50VHlwZVtdO1xuICBleGNsdWRlQWxsRGF5PzogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBFdmVudFJlbmRlcmVyKHsgZGF0ZSwgdmlldywgZXZlbnRzLCBleGNsdWRlQWxsRGF5ID0gZmFsc2UgfTogRXZlbnRSZW5kZXJlclByb3BzKSB7XG4gIGNvbnN0IHsgb3BlbkV2ZW50U3VtbWFyeSwgdXBkYXRlRXZlbnQgfSA9IHVzZUV2ZW50U3RvcmUoKTtcblxuICAvLyBDYWxlbmRhciBjb2xvcnMgZnJvbSBzdHlsZXMuY3NzIC0gbWF0Y2hpbmcgZXhhY3QgQ1NTIHZhcmlhYmxlc1xuICBjb25zdCBjYWxlbmRhckNvbG9ycyA9IFtcbiAgICB7IGJnOiAndmFyKC0tY2FsLWthcnRpayknLCBjb2xvcjogJ3doaXRlJyB9LCAgICAgIC8vICMwMzlCRTUgLSBLYXJ0aWtcbiAgICB7IGJnOiAndmFyKC0tY2FsLWJpcnRoZGF5cyknLCBjb2xvcjogJ3doaXRlJyB9LCAgIC8vICMwQjgwNDMgLSBCaXJ0aGRheXNcbiAgICB7IGJnOiAndmFyKC0tY2FsLWZhbWlseSknLCBjb2xvcjogJ3doaXRlJyB9LCAgICAgIC8vICM3OTg2Q0IgLSBGYW1pbHlcbiAgICB7IGJnOiAndmFyKC0tY2FsLXRhc2tzKScsIGNvbG9yOiAnIzEzMTMxNCcgfSwgICAgIC8vICNGNkJGMjYgLSBUYXNrc1xuICAgIHsgYmc6ICd2YXIoLS1jYWwtaG9saWRheXMpJywgY29sb3I6ICd3aGl0ZScgfSwgICAgLy8gI0U2N0M3MyAtIEhvbGlkYXlzXG4gIF07XG5cbiAgLy8gRm9yIGRheS93ZWVrIHZpZXcsIHdlIG5lZWQgdG8gZmlsdGVyIGV2ZW50cyB0aGF0IFNUQVJUIGluIHRoaXMgaG91clxuICBpZiAodmlldyA9PT0gXCJ3ZWVrXCIgfHwgdmlldyA9PT0gXCJkYXlcIikge1xuICAgIC8vIEdldCBBTEwgZXZlbnRzIGZvciB0aGUgZGF5IHRvIGNhbGN1bGF0ZSBvdmVybGFwcyBwcm9wZXJseVxuICAgIGxldCBhbGxEYXlFdmVudHMgPSBldmVudHMuZmlsdGVyKChldmVudDogQ2FsZW5kYXJFdmVudFR5cGUpID0+IHtcbiAgICAgIHJldHVybiBldmVudC5kYXRlLmZvcm1hdChcIkRELU1NLVlZXCIpID09PSBkYXRlLmZvcm1hdChcIkRELU1NLVlZXCIpO1xuICAgIH0pO1xuXG4gICAgLy8gRXhjbHVkZSBhbGwtZGF5IGV2ZW50cyBpZiByZXF1ZXN0ZWRcbiAgICBpZiAoZXhjbHVkZUFsbERheSkge1xuICAgICAgYWxsRGF5RXZlbnRzID0gYWxsRGF5RXZlbnRzLmZpbHRlcigoZXZlbnQ6IENhbGVuZGFyRXZlbnRUeXBlKSA9PiB7XG4gICAgICAgIGNvbnN0IGV2ZW50RW5kID0gZXZlbnQuZW5kRGF0ZSB8fCBldmVudC5kYXRlLmFkZCgxLCAnaG91cicpO1xuICAgICAgICBjb25zdCBkdXJhdGlvbkhvdXJzID0gZXZlbnRFbmQuZGlmZihldmVudC5kYXRlLCAnaG91cicsIHRydWUpO1xuICAgICAgICBjb25zdCBzdGFydHNBdE1pZG5pZ2h0ID0gZXZlbnQuZGF0ZS5ob3VyKCkgPT09IDAgJiYgZXZlbnQuZGF0ZS5taW51dGUoKSA9PT0gMDtcblxuICAgICAgICAvLyBFeGNsdWRlIGlmIGl0J3MgYW4gYWxsLWRheSBldmVudFxuICAgICAgICByZXR1cm4gIShkdXJhdGlvbkhvdXJzID49IDIwIHx8IChzdGFydHNBdE1pZG5pZ2h0ICYmIGR1cmF0aW9uSG91cnMgPj0gMTIpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBvdmVybGFwcyBhbmQgYXNzaWduIGNvbHVtbnMgdG8gQUxMIGV2ZW50cyBmb3IgdGhlIGRheVxuICAgIGNvbnN0IGV2ZW50c1dpdGhMYXlvdXQgPSBhbGxEYXlFdmVudHMubWFwKGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50U3RhcnQgPSBldmVudC5kYXRlO1xuICAgICAgY29uc3QgZXZlbnRFbmQgPSBldmVudC5lbmREYXRlIHx8IGV2ZW50LmRhdGUuYWRkKDEsICdob3VyJyk7XG4gICAgICByZXR1cm4geyBldmVudCwgc3RhcnQ6IGV2ZW50U3RhcnQsIGVuZDogZXZlbnRFbmQsIGNvbHVtbjogMCwgdG90YWxDb2x1bW5zOiAxLCBpc0NvbnRhaW5lZDogZmFsc2UgfTtcbiAgICB9KTtcblxuICAgIC8vIFNvcnQgZXZlbnRzIGJ5IHN0YXJ0IHRpbWUsIHRoZW4gYnkgZHVyYXRpb24gKGxvbmdlciBldmVudHMgZmlyc3QpXG4gICAgZXZlbnRzV2l0aExheW91dC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBjb25zdCBzdGFydERpZmYgPSBhLnN0YXJ0LnZhbHVlT2YoKSAtIGIuc3RhcnQudmFsdWVPZigpO1xuICAgICAgaWYgKHN0YXJ0RGlmZiAhPT0gMCkgcmV0dXJuIHN0YXJ0RGlmZjtcbiAgICAgIHJldHVybiBiLmVuZC52YWx1ZU9mKCkgLSBhLmVuZC52YWx1ZU9mKCk7IC8vIExvbmdlciBldmVudHMgZmlyc3RcbiAgICB9KTtcblxuICAgIC8vIE1hcmsgY29udGFpbmVkIGV2ZW50c1xuICAgIGV2ZW50c1dpdGhMYXlvdXQuZm9yRWFjaChldmVudExheW91dCA9PiB7XG4gICAgICBldmVudExheW91dC5pc0NvbnRhaW5lZCA9IGV2ZW50c1dpdGhMYXlvdXQuc29tZShlID0+IHtcbiAgICAgICAgaWYgKGUuZXZlbnQuaWQgPT09IGV2ZW50TGF5b3V0LmV2ZW50LmlkKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBlLnN0YXJ0LmlzU2FtZU9yQmVmb3JlKGV2ZW50TGF5b3V0LnN0YXJ0KSAmJiBlLmVuZC5pc1NhbWVPckFmdGVyKGV2ZW50TGF5b3V0LmVuZCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIEFzc2lnbiBjb2x1bW5zIHVzaW5nIGEgZ3JlZWR5IGFsZ29yaXRobVxuICAgIHR5cGUgRXZlbnRMYXlvdXQgPSB7XG4gICAgICBldmVudDogQ2FsZW5kYXJFdmVudFR5cGU7XG4gICAgICBzdGFydDogZGF5anMuRGF5anM7XG4gICAgICBlbmQ6IGRheWpzLkRheWpzO1xuICAgICAgY29sdW1uOiBudW1iZXI7XG4gICAgICB0b3RhbENvbHVtbnM6IG51bWJlcjtcbiAgICAgIGlzQ29udGFpbmVkOiBib29sZWFuO1xuICAgIH07XG4gICAgY29uc3QgY29sdW1uczogRXZlbnRMYXlvdXRbXVtdID0gW107XG5cbiAgICBldmVudHNXaXRoTGF5b3V0LmZvckVhY2goZXZlbnRMYXlvdXQgPT4ge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBldmVudCBpcyBjb21wbGV0ZWx5IGNvbnRhaW5lZCB3aXRoaW4gYW5vdGhlciBldmVudFxuICAgICAgY29uc3QgY29udGFpbmVyRXZlbnQgPSBldmVudHNXaXRoTGF5b3V0LmZpbmQoZSA9PiB7XG4gICAgICAgIGlmIChlLmV2ZW50LmlkID09PSBldmVudExheW91dC5ldmVudC5pZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBDaGVjayBpZiBldmVudExheW91dCBpcyBjb21wbGV0ZWx5IHdpdGhpbiBlXG4gICAgICAgIHJldHVybiBlLnN0YXJ0LmlzU2FtZU9yQmVmb3JlKGV2ZW50TGF5b3V0LnN0YXJ0KSAmJiBlLmVuZC5pc1NhbWVPckFmdGVyKGV2ZW50TGF5b3V0LmVuZCk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGNvbnRhaW5lckV2ZW50KSB7XG4gICAgICAgIC8vIElmIGNvbnRhaW5lZCwgcGxhY2UgaXQgaW4gdGhlIG5leHQgY29sdW1uIGFmdGVyIHRoZSBjb250YWluZXJcbiAgICAgICAgZXZlbnRMYXlvdXQuY29sdW1uID0gKGNvbnRhaW5lckV2ZW50LmNvbHVtbiB8fCAwKSArIDE7XG4gICAgICAgIC8vIEFkZCB0byBhcHByb3ByaWF0ZSBjb2x1bW4gYXJyYXlcbiAgICAgICAgaWYgKCFjb2x1bW5zW2V2ZW50TGF5b3V0LmNvbHVtbl0pIHtcbiAgICAgICAgICBjb2x1bW5zW2V2ZW50TGF5b3V0LmNvbHVtbl0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb2x1bW5zW2V2ZW50TGF5b3V0LmNvbHVtbl0ucHVzaChldmVudExheW91dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCBjb2x1bW4gd2hlcmUgdGhpcyBldmVudCBkb2Vzbid0IG92ZXJsYXAgd2l0aCBhbnkgZXhpc3RpbmcgZXZlbnRcbiAgICAgICAgbGV0IHBsYWNlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjb2x1bW5FdmVudHMgPSBjb2x1bW5zW2ldO1xuICAgICAgICAgIGNvbnN0IGhhc092ZXJsYXAgPSBjb2x1bW5FdmVudHMuc29tZShlID0+XG4gICAgICAgICAgICBlLnN0YXJ0LmlzQmVmb3JlKGV2ZW50TGF5b3V0LmVuZCkgJiYgZS5lbmQuaXNBZnRlcihldmVudExheW91dC5zdGFydClcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKCFoYXNPdmVybGFwKSB7XG4gICAgICAgICAgICBjb2x1bW5zW2ldLnB1c2goZXZlbnRMYXlvdXQpO1xuICAgICAgICAgICAgZXZlbnRMYXlvdXQuY29sdW1uID0gaTtcbiAgICAgICAgICAgIHBsYWNlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBubyBzdWl0YWJsZSBjb2x1bW4gZm91bmQsIGNyZWF0ZSBhIG5ldyBvbmVcbiAgICAgICAgaWYgKCFwbGFjZWQpIHtcbiAgICAgICAgICBjb2x1bW5zLnB1c2goW2V2ZW50TGF5b3V0XSk7XG4gICAgICAgICAgZXZlbnRMYXlvdXQuY29sdW1uID0gY29sdW1ucy5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTZXQgdG90YWxDb2x1bW5zIGZvciBhbGwgZXZlbnRzXG4gICAgY29uc3QgbWF4Q29sdW1ucyA9IGNvbHVtbnMubGVuZ3RoO1xuICAgIGV2ZW50c1dpdGhMYXlvdXQuZm9yRWFjaChldmVudExheW91dCA9PiB7XG4gICAgICAvLyBGaW5kIGFsbCBldmVudHMgdGhhdCBvdmVybGFwIHdpdGggdGhpcyBldmVudFxuICAgICAgY29uc3Qgb3ZlcmxhcHBpbmdFdmVudHMgPSBldmVudHNXaXRoTGF5b3V0LmZpbHRlcihlID0+XG4gICAgICAgIGUuZXZlbnQuaWQgIT09IGV2ZW50TGF5b3V0LmV2ZW50LmlkICYmXG4gICAgICAgIGUuc3RhcnQuaXNCZWZvcmUoZXZlbnRMYXlvdXQuZW5kKSAmJlxuICAgICAgICBlLmVuZC5pc0FmdGVyKGV2ZW50TGF5b3V0LnN0YXJ0KVxuICAgICAgKTtcblxuICAgICAgLy8gVG90YWwgY29sdW1ucyBpcyB0aGUgbWF4IGNvbHVtbiBpbmRleCBhbW9uZyBvdmVybGFwcGluZyBldmVudHMgKyAxXG4gICAgICBjb25zdCBtYXhDb2x1bW4gPSBNYXRoLm1heChcbiAgICAgICAgZXZlbnRMYXlvdXQuY29sdW1uLFxuICAgICAgICAuLi5vdmVybGFwcGluZ0V2ZW50cy5tYXAoZSA9PiBlLmNvbHVtbilcbiAgICAgICk7XG4gICAgICBldmVudExheW91dC50b3RhbENvbHVtbnMgPSBtYXhDb2x1bW4gKyAxO1xuICAgIH0pO1xuXG4gICAgY29uc3QgZXZlbnRzV2l0aENvbHVtbnMgPSBldmVudHNXaXRoTGF5b3V0O1xuXG4gICAgLy8gRmlsdGVyIHRvIG9ubHkgZXZlbnRzIHRoYXQgU1RBUlQgaW4gdGhpcyBzcGVjaWZpYyBob3VyXG4gICAgY29uc3QgZXZlbnRzU3RhcnRpbmdJblRoaXNIb3VyID0gZXZlbnRzV2l0aENvbHVtbnMuZmlsdGVyKCh7IGV2ZW50IH0pID0+IHtcbiAgICAgIHJldHVybiBldmVudC5kYXRlLmZvcm1hdChcIkRELU1NLVlZIEhIXCIpID09PSBkYXRlLmZvcm1hdChcIkRELU1NLVlZIEhIXCIpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDw+XG4gICAgICAgIHtldmVudHNTdGFydGluZ0luVGhpc0hvdXIubWFwKCh7IGV2ZW50LCBzdGFydDogZXZlbnRTdGFydCwgZW5kOiBldmVudEVuZCwgY29sdW1uLCB0b3RhbENvbHVtbnMgfSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgZHVyYXRpb24gaW4gbWludXRlc1xuICAgICAgICAgIGNvbnN0IGR1cmF0aW9uTWludXRlcyA9IGV2ZW50RW5kLmRpZmYoZXZlbnRTdGFydCwgJ21pbnV0ZScpO1xuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IChkdXJhdGlvbk1pbnV0ZXMgLyA2MCkgKiA0ODsgLy8gNDhweCBwZXIgaG91clxuXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIG9mZnNldCBmcm9tIHRvcCBvZiBob3VyIHNsb3RcbiAgICAgICAgICBjb25zdCBtaW51dGVzRnJvbUhvdXJTdGFydCA9IGV2ZW50U3RhcnQubWludXRlKCk7XG4gICAgICAgICAgY29uc3QgdG9wT2Zmc2V0ID0gKG1pbnV0ZXNGcm9tSG91clN0YXJ0IC8gNjApICogNDg7XG5cbiAgICAgICAgICAvLyBDYWxjdWxhdGUgd2lkdGggYW5kIGxlZnQgcG9zaXRpb24gYmFzZWQgb24gY29sdW1uXG4gICAgICAgICAgbGV0IGxlZnRQZXJjZW50OiBudW1iZXI7XG4gICAgICAgICAgbGV0IHdpZHRoUGVyY2VudDogbnVtYmVyO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBldmVudCBpcyBjb250YWluZWQgd2l0aGluIGFub3RoZXJcbiAgICAgICAgICBjb25zdCBpc0NvbnRhaW5lZEV2ZW50ID0gZXZlbnRzV2l0aENvbHVtbnMuc29tZShlID0+IHtcbiAgICAgICAgICAgIGlmIChlLmV2ZW50LmlkID09PSBldmVudC5pZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgLy8gTXVzdCBiZSBzdHJpY3RseSBjb250YWluZWQ6IGNvbnRhaW5lciBzdGFydHMgYXQgb3IgYmVmb3JlLCBlbmRzIGF0IG9yIGFmdGVyXG4gICAgICAgICAgICAvLyBBTkQgdGhleSBkb24ndCBoYXZlIGlkZW50aWNhbCB0aW1lIHNwYW5zXG4gICAgICAgICAgICBjb25zdCBzdGFydHNBdE9yQmVmb3JlID0gZS5zdGFydC5pc1NhbWVPckJlZm9yZShldmVudFN0YXJ0KTtcbiAgICAgICAgICAgIGNvbnN0IGVuZHNBdE9yQWZ0ZXIgPSBlLmVuZC5pc1NhbWVPckFmdGVyKGV2ZW50RW5kKTtcbiAgICAgICAgICAgIGNvbnN0IG5vdElkZW50aWNhbCA9ICEoZS5zdGFydC5pc1NhbWUoZXZlbnRTdGFydCkgJiYgZS5lbmQuaXNTYW1lKGV2ZW50RW5kKSk7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRzQXRPckJlZm9yZSAmJiBlbmRzQXRPckFmdGVyICYmIG5vdElkZW50aWNhbDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgZXZlbnQgY29udGFpbnMgb3RoZXIgZXZlbnRzXG4gICAgICAgICAgY29uc3QgaGFzQ29udGFpbmVkRXZlbnRzID0gZXZlbnRzV2l0aENvbHVtbnMuc29tZShlID0+IHtcbiAgICAgICAgICAgIGlmIChlLmV2ZW50LmlkID09PSBldmVudC5pZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgLy8gVGhpcyBldmVudCBtdXN0IHN0YXJ0IGF0IG9yIGJlZm9yZSB0aGUgb3RoZXIsIGFuZCBlbmQgYXQgb3IgYWZ0ZXIgdGhlIG90aGVyXG4gICAgICAgICAgICAvLyBBTkQgdGhleSBkb24ndCBoYXZlIGlkZW50aWNhbCB0aW1lIHNwYW5zXG4gICAgICAgICAgICBjb25zdCBzdGFydHNBdE9yQmVmb3JlID0gZXZlbnRTdGFydC5pc1NhbWVPckJlZm9yZShlLnN0YXJ0KTtcbiAgICAgICAgICAgIGNvbnN0IGVuZHNBdE9yQWZ0ZXIgPSBldmVudEVuZC5pc1NhbWVPckFmdGVyKGUuZW5kKTtcbiAgICAgICAgICAgIGNvbnN0IG5vdElkZW50aWNhbCA9ICEoZXZlbnRTdGFydC5pc1NhbWUoZS5zdGFydCkgJiYgZXZlbnRFbmQuaXNTYW1lKGUuZW5kKSk7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRzQXRPckJlZm9yZSAmJiBlbmRzQXRPckFmdGVyICYmIG5vdElkZW50aWNhbDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChpc0NvbnRhaW5lZEV2ZW50KSB7XG4gICAgICAgICAgICAvLyBDb250YWluZWQgZXZlbnQ6IHN0YXJ0cyB3aXRoIDEwJSBnYXAgZnJvbSBsZWZ0LCBleHRlbmRzIHRvIHJpZ2h0IGVkZ2VcbiAgICAgICAgICAgIGxlZnRQZXJjZW50ID0gMTA7XG4gICAgICAgICAgICB3aWR0aFBlcmNlbnQgPSA5MDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NvbnRhaW5lZEV2ZW50cykge1xuICAgICAgICAgICAgLy8gQ29udGFpbmVyIGV2ZW50OiBmdWxsIHdpZHRoXG4gICAgICAgICAgICBsZWZ0UGVyY2VudCA9IDA7XG4gICAgICAgICAgICB3aWR0aFBlcmNlbnQgPSAxMDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlZ3VsYXIgb3ZlcmxhcHBpbmcgZXZlbnRzOiBlcXVhbCBzcGxpdFxuICAgICAgICAgICAgY29uc3QgY29sdW1uV2lkdGggPSAxMDAgLyB0b3RhbENvbHVtbnM7XG4gICAgICAgICAgICBsZWZ0UGVyY2VudCA9IGNvbHVtbiAqIGNvbHVtbldpZHRoO1xuICAgICAgICAgICAgd2lkdGhQZXJjZW50ID0gY29sdW1uV2lkdGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gR2VuZXJhdGUgYSBzdGFibGUgY29sb3IgaW5kZXggZnJvbSBldmVudCBJRCBvciB1c2UgaW5kZXggYXMgZmFsbGJhY2tcbiAgICAgICAgICBsZXQgY29sb3JJbmRleCA9IGluZGV4ICUgY2FsZW5kYXJDb2xvcnMubGVuZ3RoO1xuICAgICAgICAgIGlmIChldmVudC5pZCkge1xuICAgICAgICAgICAgY29uc3QgbnVtZXJpY0lkID0gcGFyc2VJbnQoZXZlbnQuaWQpO1xuICAgICAgICAgICAgaWYgKCFpc05hTihudW1lcmljSWQpKSB7XG4gICAgICAgICAgICAgIGNvbG9ySW5kZXggPSBudW1lcmljSWQgJSBjYWxlbmRhckNvbG9ycy5sZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBGb3Igbm9uLW51bWVyaWMgSURzIChsaWtlIEdvb2dsZSBDYWxlbmRhciBJRHMpLCB1c2Ugc3RyaW5nIGhhc2hcbiAgICAgICAgICAgICAgbGV0IGhhc2ggPSAwO1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50LmlkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgZXZlbnQuaWQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICBoYXNoID0gaGFzaCAmIGhhc2g7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbG9ySW5kZXggPSBNYXRoLmFicyhoYXNoKSAlIGNhbGVuZGFyQ29sb3JzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY29sb3JzID0gY2FsZW5kYXJDb2xvcnNbY29sb3JJbmRleF07XG5cbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPFJlc2l6YWJsZUV2ZW50XG4gICAgICAgICAgICAgIGtleT17ZXZlbnQuaWR9XG4gICAgICAgICAgICAgIGV2ZW50PXtldmVudH1cbiAgICAgICAgICAgICAgZXZlbnRTdGFydD17ZXZlbnRTdGFydH1cbiAgICAgICAgICAgICAgZXZlbnRFbmQ9e2V2ZW50RW5kfVxuICAgICAgICAgICAgICBoZWlnaHQ9e2hlaWdodH1cbiAgICAgICAgICAgICAgdG9wT2Zmc2V0PXt0b3BPZmZzZXR9XG4gICAgICAgICAgICAgIGxlZnRQZXJjZW50PXtsZWZ0UGVyY2VudH1cbiAgICAgICAgICAgICAgd2lkdGhQZXJjZW50PXt3aWR0aFBlcmNlbnR9XG4gICAgICAgICAgICAgIGNvbG9ycz17Y29sb3JzfVxuICAgICAgICAgICAgICB6SW5kZXg9e2lzQ29udGFpbmVkRXZlbnQgPyAxMCA6IDV9XG4gICAgICAgICAgICAgIG9uQ2xpY2s9eyhlKSA9PiB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBvcGVuRXZlbnRTdW1tYXJ5KGV2ZW50KTtcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKTtcbiAgICAgICAgfSl9XG4gICAgICA8Lz5cbiAgICApO1xuICB9XG5cbiAgLy8gTW9udGggdmlldyAtIGtlZXAgZXhpc3RpbmcgbG9naWNcbiAgY29uc3QgZmlsdGVyZWRFdmVudHMgPSBldmVudHMuZmlsdGVyKChldmVudDogQ2FsZW5kYXJFdmVudFR5cGUpID0+IHtcbiAgICByZXR1cm4gZXZlbnQuZGF0ZS5mb3JtYXQoXCJERC1NTS1ZWVwiKSA9PT0gZGF0ZS5mb3JtYXQoXCJERC1NTS1ZWVwiKTtcbiAgfSk7XG5cbiAgLy8gRGlzcGxheSBtYXggMyBldmVudHNcbiAgY29uc3QgZGlzcGxheUV2ZW50cyA9IGZpbHRlcmVkRXZlbnRzLnNsaWNlKDAsIDMpO1xuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIHtkaXNwbGF5RXZlbnRzLm1hcCgoZXZlbnQsIGluZGV4KSA9PiB7XG4gICAgICAgIC8vIEdlbmVyYXRlIGEgc3RhYmxlIGNvbG9yIGluZGV4IGZyb20gZXZlbnQgSUQgb3IgdXNlIGluZGV4IGFzIGZhbGxiYWNrXG4gICAgICAgIGxldCBjb2xvckluZGV4ID0gaW5kZXggJSBjYWxlbmRhckNvbG9ycy5sZW5ndGg7XG4gICAgICAgIGlmIChldmVudC5pZCkge1xuICAgICAgICAgIGNvbnN0IG51bWVyaWNJZCA9IHBhcnNlSW50KGV2ZW50LmlkKTtcbiAgICAgICAgICBpZiAoIWlzTmFOKG51bWVyaWNJZCkpIHtcbiAgICAgICAgICAgIGNvbG9ySW5kZXggPSBudW1lcmljSWQgJSBjYWxlbmRhckNvbG9ycy5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZvciBub24tbnVtZXJpYyBJRHMgKGxpa2UgR29vZ2xlIENhbGVuZGFyIElEcyksIHVzZSBzdHJpbmcgaGFzaFxuICAgICAgICAgICAgbGV0IGhhc2ggPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudC5pZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBldmVudC5pZC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgICBoYXNoID0gaGFzaCAmIGhhc2g7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29sb3JJbmRleCA9IE1hdGguYWJzKGhhc2gpICUgY2FsZW5kYXJDb2xvcnMubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2xvcnMgPSBjYWxlbmRhckNvbG9yc1tjb2xvckluZGV4XTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGtleT17ZXZlbnQuaWR9XG4gICAgICAgICAgICBkYXRhLWV2ZW50LWlkPXtldmVudC5pZH1cbiAgICAgICAgICAgIGRyYWdnYWJsZT17dHJ1ZX1cbiAgICAgICAgICAgIG9uRHJhZ1N0YXJ0PXsoZSkgPT4ge1xuICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICBlLmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gJ21vdmUnO1xuICAgICAgICAgICAgICBlLmRhdGFUcmFuc2Zlci5zZXREYXRhKCdhcHBsaWNhdGlvbi9qc29uJywgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIGV2ZW50SWQ6IGV2ZW50LmlkLFxuICAgICAgICAgICAgICAgIGV2ZW50RGF0ZTogZXZlbnQuZGF0ZS5mb3JtYXQoJ1lZWVktTU0tREQgSEg6bW06c3MnKVxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIGUuY3VycmVudFRhcmdldC5zdHlsZS5vcGFjaXR5ID0gJzAuNSc7XG4gICAgICAgICAgICB9fVxuICAgICAgICAgICAgb25EcmFnRW5kPXsoZSkgPT4ge1xuICAgICAgICAgICAgICBlLmN1cnJlbnRUYXJnZXQuc3R5bGUub3BhY2l0eSA9ICcxJztcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgICBvbkNsaWNrPXsoZSkgPT4ge1xuICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICBvcGVuRXZlbnRTdW1tYXJ5KGV2ZW50KTtcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJjdXJzb3ItcG9pbnRlciB0cmFuc2l0aW9uLWFsbFwiXG4gICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICBmb250U2l6ZTogJzEycHgnLFxuICAgICAgICAgICAgICBwYWRkaW5nOiAnMnB4IDZweCcsXG4gICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzRweCcsXG4gICAgICAgICAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgICAgICAgIHRleHRPdmVyZmxvdzogJ2VsbGlwc2lzJyxcbiAgICAgICAgICAgICAgZm9udFdlaWdodDogNTAwLFxuICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiAxLjQsXG4gICAgICAgICAgICAgIGJhY2tncm91bmQ6IGNvbG9ycy5iZyxcbiAgICAgICAgICAgICAgY29sb3I6IGNvbG9ycy5jb2xvclxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIG9uTW91c2VFbnRlcj17KGUpID0+IHtcbiAgICAgICAgICAgICAgZS5jdXJyZW50VGFyZ2V0LnN0eWxlLm9wYWNpdHkgPSAnMC44JztcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgICBvbk1vdXNlTGVhdmU9eyhlKSA9PiB7XG4gICAgICAgICAgICAgIGUuY3VycmVudFRhcmdldC5zdHlsZS5vcGFjaXR5ID0gJzEnO1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7ZXZlbnQudGl0bGV9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgICB9KX1cbiAgICA8Lz5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VFdmVudFN0b3JlIiwiZGF5anMiLCJpc1NhbWVPckJlZm9yZSIsImlzU2FtZU9yQWZ0ZXIiLCJSZWFjdCIsIlJlc2l6YWJsZUV2ZW50IiwiZXh0ZW5kIiwiRXZlbnRSZW5kZXJlciIsImRhdGUiLCJ2aWV3IiwiZXZlbnRzIiwiZXhjbHVkZUFsbERheSIsIm9wZW5FdmVudFN1bW1hcnkiLCJ1cGRhdGVFdmVudCIsImNhbGVuZGFyQ29sb3JzIiwiYmciLCJjb2xvciIsImFsbERheUV2ZW50cyIsImZpbHRlciIsImV2ZW50IiwiZm9ybWF0IiwiZXZlbnRFbmQiLCJlbmREYXRlIiwiYWRkIiwiZHVyYXRpb25Ib3VycyIsImRpZmYiLCJzdGFydHNBdE1pZG5pZ2h0IiwiaG91ciIsIm1pbnV0ZSIsImV2ZW50c1dpdGhMYXlvdXQiLCJtYXAiLCJldmVudFN0YXJ0Iiwic3RhcnQiLCJlbmQiLCJjb2x1bW4iLCJ0b3RhbENvbHVtbnMiLCJpc0NvbnRhaW5lZCIsInNvcnQiLCJhIiwiYiIsInN0YXJ0RGlmZiIsInZhbHVlT2YiLCJmb3JFYWNoIiwiZXZlbnRMYXlvdXQiLCJzb21lIiwiZSIsImlkIiwiY29sdW1ucyIsImNvbnRhaW5lckV2ZW50IiwiZmluZCIsInB1c2giLCJwbGFjZWQiLCJpIiwibGVuZ3RoIiwiY29sdW1uRXZlbnRzIiwiaGFzT3ZlcmxhcCIsImlzQmVmb3JlIiwiaXNBZnRlciIsIm1heENvbHVtbnMiLCJvdmVybGFwcGluZ0V2ZW50cyIsIm1heENvbHVtbiIsIk1hdGgiLCJtYXgiLCJldmVudHNXaXRoQ29sdW1ucyIsImV2ZW50c1N0YXJ0aW5nSW5UaGlzSG91ciIsImluZGV4IiwiZHVyYXRpb25NaW51dGVzIiwiaGVpZ2h0IiwibWludXRlc0Zyb21Ib3VyU3RhcnQiLCJ0b3BPZmZzZXQiLCJsZWZ0UGVyY2VudCIsIndpZHRoUGVyY2VudCIsImlzQ29udGFpbmVkRXZlbnQiLCJzdGFydHNBdE9yQmVmb3JlIiwiZW5kc0F0T3JBZnRlciIsIm5vdElkZW50aWNhbCIsImlzU2FtZSIsImhhc0NvbnRhaW5lZEV2ZW50cyIsImNvbHVtbldpZHRoIiwiY29sb3JJbmRleCIsIm51bWVyaWNJZCIsInBhcnNlSW50IiwiaXNOYU4iLCJoYXNoIiwiY2hhckNvZGVBdCIsImFicyIsImNvbG9ycyIsInpJbmRleCIsIm9uQ2xpY2siLCJzdG9wUHJvcGFnYXRpb24iLCJmaWx0ZXJlZEV2ZW50cyIsImRpc3BsYXlFdmVudHMiLCJzbGljZSIsImRpdiIsImRhdGEtZXZlbnQtaWQiLCJkcmFnZ2FibGUiLCJvbkRyYWdTdGFydCIsImRhdGFUcmFuc2ZlciIsImVmZmVjdEFsbG93ZWQiLCJzZXREYXRhIiwiSlNPTiIsInN0cmluZ2lmeSIsImV2ZW50SWQiLCJldmVudERhdGUiLCJjdXJyZW50VGFyZ2V0Iiwic3R5bGUiLCJvcGFjaXR5Iiwib25EcmFnRW5kIiwiY2xhc3NOYW1lIiwiZm9udFNpemUiLCJwYWRkaW5nIiwiYm9yZGVyUmFkaXVzIiwid2hpdGVTcGFjZSIsIm92ZXJmbG93IiwidGV4dE92ZXJmbG93IiwiZm9udFdlaWdodCIsImxpbmVIZWlnaHQiLCJiYWNrZ3JvdW5kIiwib25Nb3VzZUVudGVyIiwib25Nb3VzZUxlYXZlIiwidGl0bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/event-renderer.tsx\n"));

/***/ })

});