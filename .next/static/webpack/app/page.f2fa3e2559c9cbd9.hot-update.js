"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/event-renderer.tsx":
/*!***************************************!*\
  !*** ./components/event-renderer.tsx ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventRenderer: function() { return /* binding */ EventRenderer; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _lib_store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/store */ \"(app-pages-browser)/./lib/store.ts\");\n/* harmony import */ var dayjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! dayjs */ \"(app-pages-browser)/./node_modules/dayjs/dayjs.min.js\");\n/* harmony import */ var dayjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(dayjs__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var dayjs_plugin_isSameOrBefore__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! dayjs/plugin/isSameOrBefore */ \"(app-pages-browser)/./node_modules/dayjs/plugin/isSameOrBefore.js\");\n/* harmony import */ var dayjs_plugin_isSameOrBefore__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(dayjs_plugin_isSameOrBefore__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var dayjs_plugin_isSameOrAfter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! dayjs/plugin/isSameOrAfter */ \"(app-pages-browser)/./node_modules/dayjs/plugin/isSameOrAfter.js\");\n/* harmony import */ var dayjs_plugin_isSameOrAfter__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(dayjs_plugin_isSameOrAfter__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _resizable_event__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./resizable-event */ \"(app-pages-browser)/./components/resizable-event.tsx\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\ndayjs__WEBPACK_IMPORTED_MODULE_2___default().extend((dayjs_plugin_isSameOrBefore__WEBPACK_IMPORTED_MODULE_3___default()));\ndayjs__WEBPACK_IMPORTED_MODULE_2___default().extend((dayjs_plugin_isSameOrAfter__WEBPACK_IMPORTED_MODULE_4___default()));\nfunction EventRenderer(param) {\n    let { date, view, events, excludeAllDay = false } = param;\n    _s();\n    const { openEventSummary, updateEvent } = (0,_lib_store__WEBPACK_IMPORTED_MODULE_1__.useEventStore)();\n    // Calendar colors from styles.css - matching exact CSS variables\n    const calendarColors = [\n        {\n            bg: \"var(--cal-kartik)\",\n            color: \"white\"\n        },\n        {\n            bg: \"var(--cal-birthdays)\",\n            color: \"white\"\n        },\n        {\n            bg: \"var(--cal-family)\",\n            color: \"white\"\n        },\n        {\n            bg: \"var(--cal-tasks)\",\n            color: \"#131314\"\n        },\n        {\n            bg: \"var(--cal-holidays)\",\n            color: \"white\"\n        }\n    ];\n    // For day/week view, we need to filter events that START in this hour\n    if (view === \"week\" || view === \"day\") {\n        // Get ALL events for the day to calculate overlaps properly\n        let allDayEvents = events.filter((event)=>{\n            return event.date.format(\"DD-MM-YY\") === date.format(\"DD-MM-YY\");\n        });\n        // Exclude all-day events if requested\n        if (excludeAllDay) {\n            allDayEvents = allDayEvents.filter((event)=>{\n                const eventEnd = event.endDate || event.date.add(1, \"hour\");\n                const durationHours = eventEnd.diff(event.date, \"hour\", true);\n                const startsAtMidnight = event.date.hour() === 0 && event.date.minute() === 0;\n                // Exclude if it's an all-day event\n                return !(durationHours >= 20 || startsAtMidnight && durationHours >= 12);\n            });\n        }\n        // Calculate overlaps and assign columns to ALL events for the day\n        const eventsWithLayout = allDayEvents.map((event)=>{\n            const eventStart = event.date;\n            const eventEnd = event.endDate || event.date.add(1, \"hour\");\n            return {\n                event,\n                start: eventStart,\n                end: eventEnd,\n                column: 0,\n                totalColumns: 1,\n                isContained: false\n            };\n        });\n        // Sort events by start time, then by duration (longer events first)\n        eventsWithLayout.sort((a, b)=>{\n            const startDiff = a.start.valueOf() - b.start.valueOf();\n            if (startDiff !== 0) return startDiff;\n            return b.end.valueOf() - a.end.valueOf(); // Longer events first\n        });\n        // Mark contained events\n        eventsWithLayout.forEach((eventLayout)=>{\n            eventLayout.isContained = eventsWithLayout.some((e)=>{\n                if (e.event.id === eventLayout.event.id) return false;\n                return e.start.isSameOrBefore(eventLayout.start) && e.end.isSameOrAfter(eventLayout.end);\n            });\n        });\n        // Assign columns using a greedy algorithm\n        const columns = [];\n        eventsWithLayout.forEach((eventLayout)=>{\n            // Check if this event is completely contained within another event\n            const containerEvent = eventsWithLayout.find((e)=>{\n                if (e.event.id === eventLayout.event.id) return false;\n                // Check if eventLayout is completely within e\n                return e.start.isSameOrBefore(eventLayout.start) && e.end.isSameOrAfter(eventLayout.end);\n            });\n            if (containerEvent) {\n                // If contained, place it in the next column after the container\n                eventLayout.column = (containerEvent.column || 0) + 1;\n                // Add to appropriate column array\n                if (!columns[eventLayout.column]) {\n                    columns[eventLayout.column] = [];\n                }\n                columns[eventLayout.column].push(eventLayout);\n            } else {\n                // Find the first column where this event doesn't overlap with any existing event\n                let placed = false;\n                for(let i = 0; i < columns.length; i++){\n                    const columnEvents = columns[i];\n                    const hasOverlap = columnEvents.some((e)=>e.start.isBefore(eventLayout.end) && e.end.isAfter(eventLayout.start));\n                    if (!hasOverlap) {\n                        columns[i].push(eventLayout);\n                        eventLayout.column = i;\n                        placed = true;\n                        break;\n                    }\n                }\n                // If no suitable column found, create a new one\n                if (!placed) {\n                    columns.push([\n                        eventLayout\n                    ]);\n                    eventLayout.column = columns.length - 1;\n                }\n            }\n        });\n        // Set totalColumns for all events\n        const maxColumns = columns.length;\n        eventsWithLayout.forEach((eventLayout)=>{\n            // Find all events that overlap with this event\n            const overlappingEvents = eventsWithLayout.filter((e)=>e.event.id !== eventLayout.event.id && e.start.isBefore(eventLayout.end) && e.end.isAfter(eventLayout.start));\n            // Total columns is the max column index among overlapping events + 1\n            const maxColumn = Math.max(eventLayout.column, ...overlappingEvents.map((e)=>e.column));\n            eventLayout.totalColumns = maxColumn + 1;\n        });\n        const eventsWithColumns = eventsWithLayout;\n        // Filter to only events that START in this specific hour\n        const eventsStartingInThisHour = eventsWithColumns.filter((param)=>{\n            let { event } = param;\n            return event.date.format(\"DD-MM-YY HH\") === date.format(\"DD-MM-YY HH\");\n        });\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: eventsStartingInThisHour.map((param, index)=>{\n                let { event, start: eventStart, end: eventEnd, column, totalColumns } = param;\n                // Calculate duration in minutes\n                const durationMinutes = eventEnd.diff(eventStart, \"minute\");\n                const height = durationMinutes / 60 * 48; // 48px per hour\n                // Calculate offset from top of hour slot\n                const minutesFromHourStart = eventStart.minute();\n                const topOffset = minutesFromHourStart / 60 * 48;\n                // Calculate width and left position based on column\n                let leftPercent;\n                let widthPercent;\n                // Check if this event is contained within another\n                const isContainedEvent = eventsWithColumns.some((e)=>{\n                    if (e.event.id === event.id) return false;\n                    // Must be strictly contained: container starts at or before, ends at or after\n                    // AND they don't have identical time spans\n                    const startsAtOrBefore = e.start.isSameOrBefore(eventStart);\n                    const endsAtOrAfter = e.end.isSameOrAfter(eventEnd);\n                    const notIdentical = !(e.start.isSame(eventStart) && e.end.isSame(eventEnd));\n                    return startsAtOrBefore && endsAtOrAfter && notIdentical;\n                });\n                // Check if this event contains other events\n                const hasContainedEvents = eventsWithColumns.some((e)=>{\n                    if (e.event.id === event.id) return false;\n                    // This event must start at or before the other, and end at or after the other\n                    // AND they don't have identical time spans\n                    const startsAtOrBefore = eventStart.isSameOrBefore(e.start);\n                    const endsAtOrAfter = eventEnd.isSameOrAfter(e.end);\n                    const notIdentical = !(eventStart.isSame(e.start) && eventEnd.isSame(e.end));\n                    return startsAtOrBefore && endsAtOrAfter && notIdentical;\n                });\n                if (isContainedEvent) {\n                    // Contained event: starts with 10% gap from left, extends to right edge\n                    leftPercent = 10;\n                    widthPercent = 90;\n                } else if (hasContainedEvents) {\n                    // Container event: full width\n                    leftPercent = 0;\n                    widthPercent = 100;\n                } else {\n                    // Regular overlapping events: equal split\n                    const columnWidth = 100 / totalColumns;\n                    leftPercent = column * columnWidth;\n                    widthPercent = columnWidth;\n                }\n                // Generate a stable color index from event ID or use index as fallback\n                let colorIndex = index % calendarColors.length;\n                if (event.id) {\n                    const numericId = parseInt(event.id);\n                    if (!isNaN(numericId)) {\n                        colorIndex = numericId % calendarColors.length;\n                    } else {\n                        // For non-numeric IDs (like Google Calendar IDs), use string hash\n                        let hash = 0;\n                        for(let i = 0; i < event.id.length; i++){\n                            hash = (hash << 5) - hash + event.id.charCodeAt(i);\n                            hash = hash & hash; // Convert to 32bit integer\n                        }\n                        colorIndex = Math.abs(hash) % calendarColors.length;\n                    }\n                }\n                const colors = calendarColors[colorIndex];\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_resizable_event__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                    event: event,\n                    eventStart: eventStart,\n                    eventEnd: eventEnd,\n                    height: height,\n                    topOffset: topOffset,\n                    leftPercent: leftPercent,\n                    widthPercent: widthPercent,\n                    colors: colors,\n                    zIndex: isContainedEvent ? 10 : 5,\n                    onClick: (e)=>{\n                        e.stopPropagation();\n                        console.log(\"[EventRenderer] Opening event summary for:\", event.title);\n                        openEventSummary(event);\n                    }\n                }, event.id, false, {\n                    fileName: \"/Users/kartikgupta/Downloads/Google-Calender/components/event-renderer.tsx\",\n                    lineNumber: 213,\n                    columnNumber: 13\n                }, this);\n            })\n        }, void 0, false);\n    }\n    // Month view - keep existing logic\n    const filteredEvents = events.filter((event)=>{\n        return event.date.format(\"DD-MM-YY\") === date.format(\"DD-MM-YY\");\n    });\n    // Display max 3 events\n    const displayEvents = filteredEvents.slice(0, 3);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: displayEvents.map((event, index)=>{\n            // Generate a stable color index from event ID or use index as fallback\n            let colorIndex = index % calendarColors.length;\n            if (event.id) {\n                const numericId = parseInt(event.id);\n                if (!isNaN(numericId)) {\n                    colorIndex = numericId % calendarColors.length;\n                } else {\n                    // For non-numeric IDs (like Google Calendar IDs), use string hash\n                    let hash = 0;\n                    for(let i = 0; i < event.id.length; i++){\n                        hash = (hash << 5) - hash + event.id.charCodeAt(i);\n                        hash = hash & hash; // Convert to 32bit integer\n                    }\n                    colorIndex = Math.abs(hash) % calendarColors.length;\n                }\n            }\n            const colors = calendarColors[colorIndex];\n            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                \"data-event-id\": event.id,\n                draggable: true,\n                onDragStart: (e)=>{\n                    e.stopPropagation();\n                    e.dataTransfer.effectAllowed = \"move\";\n                    e.dataTransfer.setData(\"application/json\", JSON.stringify({\n                        eventId: event.id,\n                        eventDate: event.date.format(\"YYYY-MM-DD HH:mm:ss\")\n                    }));\n                    e.currentTarget.style.opacity = \"0.5\";\n                },\n                onDragEnd: (e)=>{\n                    e.currentTarget.style.opacity = \"1\";\n                },\n                onClick: (e)=>{\n                    e.stopPropagation();\n                    openEventSummary(event);\n                },\n                className: \"cursor-pointer transition-all\",\n                style: {\n                    fontSize: \"12px\",\n                    padding: \"2px 6px\",\n                    borderRadius: \"4px\",\n                    whiteSpace: \"nowrap\",\n                    overflow: \"hidden\",\n                    textOverflow: \"ellipsis\",\n                    fontWeight: 500,\n                    lineHeight: 1.4,\n                    background: colors.bg,\n                    color: colors.color\n                },\n                onMouseEnter: (e)=>{\n                    e.currentTarget.style.opacity = \"0.8\";\n                },\n                onMouseLeave: (e)=>{\n                    e.currentTarget.style.opacity = \"1\";\n                },\n                children: event.title\n            }, event.id, false, {\n                fileName: \"/Users/kartikgupta/Downloads/Google-Calender/components/event-renderer.tsx\",\n                lineNumber: 266,\n                columnNumber: 11\n            }, this);\n        })\n    }, void 0, false);\n}\n_s(EventRenderer, \"yRKFIAESwGl8pRA8+q/h6/0co4k=\", false, function() {\n    return [\n        _lib_store__WEBPACK_IMPORTED_MODULE_1__.useEventStore\n    ];\n});\n_c = EventRenderer;\nvar _c;\n$RefreshReg$(_c, \"EventRenderer\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvZXZlbnQtcmVuZGVyZXIudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQytEO0FBRXJDO0FBQytCO0FBQ0Y7QUFDN0I7QUFDcUI7QUFFL0NDLG1EQUFZLENBQUNDLG9FQUFjQTtBQUMzQkQsbURBQVksQ0FBQ0UsbUVBQWFBO0FBU25CLFNBQVNJLGNBQWMsS0FBaUU7UUFBakUsRUFBRUMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsZ0JBQWdCLEtBQUssRUFBc0IsR0FBakU7O0lBQzVCLE1BQU0sRUFBRUMsZ0JBQWdCLEVBQUVDLFdBQVcsRUFBRSxHQUFHYix5REFBYUE7SUFFdkQsaUVBQWlFO0lBQ2pFLE1BQU1jLGlCQUFpQjtRQUNyQjtZQUFFQyxJQUFJO1lBQXFCQyxPQUFPO1FBQVE7UUFDMUM7WUFBRUQsSUFBSTtZQUF3QkMsT0FBTztRQUFRO1FBQzdDO1lBQUVELElBQUk7WUFBcUJDLE9BQU87UUFBUTtRQUMxQztZQUFFRCxJQUFJO1lBQW9CQyxPQUFPO1FBQVU7UUFDM0M7WUFBRUQsSUFBSTtZQUF1QkMsT0FBTztRQUFRO0tBQzdDO0lBRUQsc0VBQXNFO0lBQ3RFLElBQUlQLFNBQVMsVUFBVUEsU0FBUyxPQUFPO1FBQ3JDLDREQUE0RDtRQUM1RCxJQUFJUSxlQUFlUCxPQUFPUSxNQUFNLENBQUMsQ0FBQ0M7WUFDaEMsT0FBT0EsTUFBTVgsSUFBSSxDQUFDWSxNQUFNLENBQUMsZ0JBQWdCWixLQUFLWSxNQUFNLENBQUM7UUFDdkQ7UUFFQSxzQ0FBc0M7UUFDdEMsSUFBSVQsZUFBZTtZQUNqQk0sZUFBZUEsYUFBYUMsTUFBTSxDQUFDLENBQUNDO2dCQUNsQyxNQUFNRSxXQUFXRixNQUFNRyxPQUFPLElBQUlILE1BQU1YLElBQUksQ0FBQ2UsR0FBRyxDQUFDLEdBQUc7Z0JBQ3BELE1BQU1DLGdCQUFnQkgsU0FBU0ksSUFBSSxDQUFDTixNQUFNWCxJQUFJLEVBQUUsUUFB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OzBCQUVDMUYsTUFBTXlFLEtBQUs7ZUF2Q1B6RSxNQUFNMkIsRUFBRTs7Ozs7UUEwQ25COztBQUdOO0dBcFNnQnZDOztRQUM0QlAscURBQWFBOzs7S0FEekNPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvZXZlbnQtcmVuZGVyZXIudHN4PzI5NjYiXSwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgeyBDYWxlbmRhckV2ZW50VHlwZSwgdXNlRXZlbnRTdG9yZSB9IGZyb20gXCJAL2xpYi9zdG9yZVwiO1xuXG5pbXBvcnQgZGF5anMgZnJvbSBcImRheWpzXCI7XG5pbXBvcnQgaXNTYW1lT3JCZWZvcmUgZnJvbSBcImRheWpzL3BsdWdpbi9pc1NhbWVPckJlZm9yZVwiO1xuaW1wb3J0IGlzU2FtZU9yQWZ0ZXIgZnJvbSBcImRheWpzL3BsdWdpbi9pc1NhbWVPckFmdGVyXCI7XG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUmVzaXphYmxlRXZlbnQgZnJvbSBcIi4vcmVzaXphYmxlLWV2ZW50XCI7XG5cbmRheWpzLmV4dGVuZChpc1NhbWVPckJlZm9yZSk7XG5kYXlqcy5leHRlbmQoaXNTYW1lT3JBZnRlcik7XG5cbnR5cGUgRXZlbnRSZW5kZXJlclByb3BzID0ge1xuICBkYXRlOiBkYXlqcy5EYXlqcztcbiAgdmlldzogXCJtb250aFwiIHwgXCJ3ZWVrXCIgfCBcImRheVwiO1xuICBldmVudHM6IENhbGVuZGFyRXZlbnRUeXBlW107XG4gIGV4Y2x1ZGVBbGxEYXk/OiBib29sZWFuO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIEV2ZW50UmVuZGVyZXIoeyBkYXRlLCB2aWV3LCBldmVudHMsIGV4Y2x1ZGVBbGxEYXkgPSBmYWxzZSB9OiBFdmVudFJlbmRlcmVyUHJvcHMpIHtcbiAgY29uc3QgeyBvcGVuRXZlbnRTdW1tYXJ5LCB1cGRhdGVFdmVudCB9ID0gdXNlRXZlbnRTdG9yZSgpO1xuXG4gIC8vIENhbGVuZGFyIGNvbG9ycyBmcm9tIHN0eWxlcy5jc3MgLSBtYXRjaGluZyBleGFjdCBDU1MgdmFyaWFibGVzXG4gIGNvbnN0IGNhbGVuZGFyQ29sb3JzID0gW1xuICAgIHsgYmc6ICd2YXIoLS1jYWwta2FydGlrKScsIGNvbG9yOiAnd2hpdGUnIH0sICAgICAgLy8gIzAzOUJFNSAtIEthcnRpa1xuICAgIHsgYmc6ICd2YXIoLS1jYWwtYmlydGhkYXlzKScsIGNvbG9yOiAnd2hpdGUnIH0sICAgLy8gIzBCODA0MyAtIEJpcnRoZGF5c1xuICAgIHsgYmc6ICd2YXIoLS1jYWwtZmFtaWx5KScsIGNvbG9yOiAnd2hpdGUnIH0sICAgICAgLy8gIzc5ODZDQiAtIEZhbWlseVxuICAgIHsgYmc6ICd2YXIoLS1jYWwtdGFza3MpJywgY29sb3I6ICcjMTMxMzE0JyB9LCAgICAgLy8gI0Y2QkYyNiAtIFRhc2tzXG4gICAgeyBiZzogJ3ZhcigtLWNhbC1ob2xpZGF5cyknLCBjb2xvcjogJ3doaXRlJyB9LCAgICAvLyAjRTY3QzczIC0gSG9saWRheXNcbiAgXTtcblxuICAvLyBGb3IgZGF5L3dlZWsgdmlldywgd2UgbmVlZCB0byBmaWx0ZXIgZXZlbnRzIHRoYXQgU1RBUlQgaW4gdGhpcyBob3VyXG4gIGlmICh2aWV3ID09PSBcIndlZWtcIiB8fCB2aWV3ID09PSBcImRheVwiKSB7XG4gICAgLy8gR2V0IEFMTCBldmVudHMgZm9yIHRoZSBkYXkgdG8gY2FsY3VsYXRlIG92ZXJsYXBzIHByb3Blcmx5XG4gICAgbGV0IGFsbERheUV2ZW50cyA9IGV2ZW50cy5maWx0ZXIoKGV2ZW50OiBDYWxlbmRhckV2ZW50VHlwZSkgPT4ge1xuICAgICAgcmV0dXJuIGV2ZW50LmRhdGUuZm9ybWF0KFwiREQtTU0tWVlcIikgPT09IGRhdGUuZm9ybWF0KFwiREQtTU0tWVlcIik7XG4gICAgfSk7XG5cbiAgICAvLyBFeGNsdWRlIGFsbC1kYXkgZXZlbnRzIGlmIHJlcXVlc3RlZFxuICAgIGlmIChleGNsdWRlQWxsRGF5KSB7XG4gICAgICBhbGxEYXlFdmVudHMgPSBhbGxEYXlFdmVudHMuZmlsdGVyKChldmVudDogQ2FsZW5kYXJFdmVudFR5cGUpID0+IHtcbiAgICAgICAgY29uc3QgZXZlbnRFbmQgPSBldmVudC5lbmREYXRlIHx8IGV2ZW50LmRhdGUuYWRkKDEsICdob3VyJyk7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uSG91cnMgPSBldmVudEVuZC5kaWZmKGV2ZW50LmRhdGUsICdob3VyJywgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHN0YXJ0c0F0TWlkbmlnaHQgPSBldmVudC5kYXRlLmhvdXIoKSA9PT0gMCAmJiBldmVudC5kYXRlLm1pbnV0ZSgpID09PSAwO1xuXG4gICAgICAgIC8vIEV4Y2x1ZGUgaWYgaXQncyBhbiBhbGwtZGF5IGV2ZW50XG4gICAgICAgIHJldHVybiAhKGR1cmF0aW9uSG91cnMgPj0gMjAgfHwgKHN0YXJ0c0F0TWlkbmlnaHQgJiYgZHVyYXRpb25Ib3VycyA+PSAxMikpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIG92ZXJsYXBzIGFuZCBhc3NpZ24gY29sdW1ucyB0byBBTEwgZXZlbnRzIGZvciB0aGUgZGF5XG4gICAgY29uc3QgZXZlbnRzV2l0aExheW91dCA9IGFsbERheUV2ZW50cy5tYXAoZXZlbnQgPT4ge1xuICAgICAgY29uc3QgZXZlbnRTdGFydCA9IGV2ZW50LmRhdGU7XG4gICAgICBjb25zdCBldmVudEVuZCA9IGV2ZW50LmVuZERhdGUgfHwgZXZlbnQuZGF0ZS5hZGQoMSwgJ2hvdXInKTtcbiAgICAgIHJldHVybiB7IGV2ZW50LCBzdGFydDogZXZlbnRTdGFydCwgZW5kOiBldmVudEVuZCwgY29sdW1uOiAwLCB0b3RhbENvbHVtbnM6IDEsIGlzQ29udGFpbmVkOiBmYWxzZSB9O1xuICAgIH0pO1xuXG4gICAgLy8gU29ydCBldmVudHMgYnkgc3RhcnQgdGltZSwgdGhlbiBieSBkdXJhdGlvbiAobG9uZ2VyIGV2ZW50cyBmaXJzdClcbiAgICBldmVudHNXaXRoTGF5b3V0LnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0RGlmZiA9IGEuc3RhcnQudmFsdWVPZigpIC0gYi5zdGFydC52YWx1ZU9mKCk7XG4gICAgICBpZiAoc3RhcnREaWZmICE9PSAwKSByZXR1cm4gc3RhcnREaWZmO1xuICAgICAgcmV0dXJuIGIuZW5kLnZhbHVlT2YoKSAtIGEuZW5kLnZhbHVlT2YoKTsgLy8gTG9uZ2VyIGV2ZW50cyBmaXJzdFxuICAgIH0pO1xuXG4gICAgLy8gTWFyayBjb250YWluZWQgZXZlbnRzXG4gICAgZXZlbnRzV2l0aExheW91dC5mb3JFYWNoKGV2ZW50TGF5b3V0ID0+IHtcbiAgICAgIGV2ZW50TGF5b3V0LmlzQ29udGFpbmVkID0gZXZlbnRzV2l0aExheW91dC5zb21lKGUgPT4ge1xuICAgICAgICBpZiAoZS5ldmVudC5pZCA9PT0gZXZlbnRMYXlvdXQuZXZlbnQuaWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGUuc3RhcnQuaXNTYW1lT3JCZWZvcmUoZXZlbnRMYXlvdXQuc3RhcnQpICYmIGUuZW5kLmlzU2FtZU9yQWZ0ZXIoZXZlbnRMYXlvdXQuZW5kKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gQXNzaWduIGNvbHVtbnMgdXNpbmcgYSBncmVlZHkgYWxnb3JpdGhtXG4gICAgY29uc3QgY29sdW1uczogdHlwZW9mIGV2ZW50c1dpdGhMYXlvdXRbXVtdID0gW107XG5cbiAgICBldmVudHNXaXRoTGF5b3V0LmZvckVhY2goZXZlbnRMYXlvdXQgPT4ge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBldmVudCBpcyBjb21wbGV0ZWx5IGNvbnRhaW5lZCB3aXRoaW4gYW5vdGhlciBldmVudFxuICAgICAgY29uc3QgY29udGFpbmVyRXZlbnQgPSBldmVudHNXaXRoTGF5b3V0LmZpbmQoZSA9PiB7XG4gICAgICAgIGlmIChlLmV2ZW50LmlkID09PSBldmVudExheW91dC5ldmVudC5pZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBDaGVjayBpZiBldmVudExheW91dCBpcyBjb21wbGV0ZWx5IHdpdGhpbiBlXG4gICAgICAgIHJldHVybiBlLnN0YXJ0LmlzU2FtZU9yQmVmb3JlKGV2ZW50TGF5b3V0LnN0YXJ0KSAmJiBlLmVuZC5pc1NhbWVPckFmdGVyKGV2ZW50TGF5b3V0LmVuZCk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGNvbnRhaW5lckV2ZW50KSB7XG4gICAgICAgIC8vIElmIGNvbnRhaW5lZCwgcGxhY2UgaXQgaW4gdGhlIG5leHQgY29sdW1uIGFmdGVyIHRoZSBjb250YWluZXJcbiAgICAgICAgZXZlbnRMYXlvdXQuY29sdW1uID0gKGNvbnRhaW5lckV2ZW50LmNvbHVtbiB8fCAwKSArIDE7XG4gICAgICAgIC8vIEFkZCB0byBhcHByb3ByaWF0ZSBjb2x1bW4gYXJyYXlcbiAgICAgICAgaWYgKCFjb2x1bW5zW2V2ZW50TGF5b3V0LmNvbHVtbl0pIHtcbiAgICAgICAgICBjb2x1bW5zW2V2ZW50TGF5b3V0LmNvbHVtbl0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb2x1bW5zW2V2ZW50TGF5b3V0LmNvbHVtbl0ucHVzaChldmVudExheW91dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCBjb2x1bW4gd2hlcmUgdGhpcyBldmVudCBkb2Vzbid0IG92ZXJsYXAgd2l0aCBhbnkgZXhpc3RpbmcgZXZlbnRcbiAgICAgICAgbGV0IHBsYWNlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjb2x1bW5FdmVudHMgPSBjb2x1bW5zW2ldO1xuICAgICAgICAgIGNvbnN0IGhhc092ZXJsYXAgPSBjb2x1bW5FdmVudHMuc29tZShlID0+XG4gICAgICAgICAgICBlLnN0YXJ0LmlzQmVmb3JlKGV2ZW50TGF5b3V0LmVuZCkgJiYgZS5lbmQuaXNBZnRlcihldmVudExheW91dC5zdGFydClcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKCFoYXNPdmVybGFwKSB7XG4gICAgICAgICAgICBjb2x1bW5zW2ldLnB1c2goZXZlbnRMYXlvdXQpO1xuICAgICAgICAgICAgZXZlbnRMYXlvdXQuY29sdW1uID0gaTtcbiAgICAgICAgICAgIHBsYWNlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBubyBzdWl0YWJsZSBjb2x1bW4gZm91bmQsIGNyZWF0ZSBhIG5ldyBvbmVcbiAgICAgICAgaWYgKCFwbGFjZWQpIHtcbiAgICAgICAgICBjb2x1bW5zLnB1c2goW2V2ZW50TGF5b3V0XSk7XG4gICAgICAgICAgZXZlbnRMYXlvdXQuY29sdW1uID0gY29sdW1ucy5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTZXQgdG90YWxDb2x1bW5zIGZvciBhbGwgZXZlbnRzXG4gICAgY29uc3QgbWF4Q29sdW1ucyA9IGNvbHVtbnMubGVuZ3RoO1xuICAgIGV2ZW50c1dpdGhMYXlvdXQuZm9yRWFjaChldmVudExheW91dCA9PiB7XG4gICAgICAvLyBGaW5kIGFsbCBldmVudHMgdGhhdCBvdmVybGFwIHdpdGggdGhpcyBldmVudFxuICAgICAgY29uc3Qgb3ZlcmxhcHBpbmdFdmVudHMgPSBldmVudHNXaXRoTGF5b3V0LmZpbHRlcihlID0+XG4gICAgICAgIGUuZXZlbnQuaWQgIT09IGV2ZW50TGF5b3V0LmV2ZW50LmlkICYmXG4gICAgICAgIGUuc3RhcnQuaXNCZWZvcmUoZXZlbnRMYXlvdXQuZW5kKSAmJlxuICAgICAgICBlLmVuZC5pc0FmdGVyKGV2ZW50TGF5b3V0LnN0YXJ0KVxuICAgICAgKTtcblxuICAgICAgLy8gVG90YWwgY29sdW1ucyBpcyB0aGUgbWF4IGNvbHVtbiBpbmRleCBhbW9uZyBvdmVybGFwcGluZyBldmVudHMgKyAxXG4gICAgICBjb25zdCBtYXhDb2x1bW4gPSBNYXRoLm1heChcbiAgICAgICAgZXZlbnRMYXlvdXQuY29sdW1uLFxuICAgICAgICAuLi5vdmVybGFwcGluZ0V2ZW50cy5tYXAoZSA9PiBlLmNvbHVtbilcbiAgICAgICk7XG4gICAgICBldmVudExheW91dC50b3RhbENvbHVtbnMgPSBtYXhDb2x1bW4gKyAxO1xuICAgIH0pO1xuXG4gICAgY29uc3QgZXZlbnRzV2l0aENvbHVtbnMgPSBldmVudHNXaXRoTGF5b3V0O1xuXG4gICAgLy8gRmlsdGVyIHRvIG9ubHkgZXZlbnRzIHRoYXQgU1RBUlQgaW4gdGhpcyBzcGVjaWZpYyBob3VyXG4gICAgY29uc3QgZXZlbnRzU3RhcnRpbmdJblRoaXNIb3VyID0gZXZlbnRzV2l0aENvbHVtbnMuZmlsdGVyKCh7IGV2ZW50IH0pID0+IHtcbiAgICAgIHJldHVybiBldmVudC5kYXRlLmZvcm1hdChcIkRELU1NLVlZIEhIXCIpID09PSBkYXRlLmZvcm1hdChcIkRELU1NLVlZIEhIXCIpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDw+XG4gICAgICAgIHtldmVudHNTdGFydGluZ0luVGhpc0hvdXIubWFwKCh7IGV2ZW50LCBzdGFydDogZXZlbnRTdGFydCwgZW5kOiBldmVudEVuZCwgY29sdW1uLCB0b3RhbENvbHVtbnMgfSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgZHVyYXRpb24gaW4gbWludXRlc1xuICAgICAgICAgIGNvbnN0IGR1cmF0aW9uTWludXRlcyA9IGV2ZW50RW5kLmRpZmYoZXZlbnRTdGFydCwgJ21pbnV0ZScpO1xuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IChkdXJhdGlvbk1pbnV0ZXMgLyA2MCkgKiA0ODsgLy8gNDhweCBwZXIgaG91clxuXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIG9mZnNldCBmcm9tIHRvcCBvZiBob3VyIHNsb3RcbiAgICAgICAgICBjb25zdCBtaW51dGVzRnJvbUhvdXJTdGFydCA9IGV2ZW50U3RhcnQubWludXRlKCk7XG4gICAgICAgICAgY29uc3QgdG9wT2Zmc2V0ID0gKG1pbnV0ZXNGcm9tSG91clN0YXJ0IC8gNjApICogNDg7XG5cbiAgICAgICAgICAvLyBDYWxjdWxhdGUgd2lkdGggYW5kIGxlZnQgcG9zaXRpb24gYmFzZWQgb24gY29sdW1uXG4gICAgICAgICAgbGV0IGxlZnRQZXJjZW50OiBudW1iZXI7XG4gICAgICAgICAgbGV0IHdpZHRoUGVyY2VudDogbnVtYmVyO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBldmVudCBpcyBjb250YWluZWQgd2l0aGluIGFub3RoZXJcbiAgICAgICAgICBjb25zdCBpc0NvbnRhaW5lZEV2ZW50ID0gZXZlbnRzV2l0aENvbHVtbnMuc29tZShlID0+IHtcbiAgICAgICAgICAgIGlmIChlLmV2ZW50LmlkID09PSBldmVudC5pZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgLy8gTXVzdCBiZSBzdHJpY3RseSBjb250YWluZWQ6IGNvbnRhaW5lciBzdGFydHMgYXQgb3IgYmVmb3JlLCBlbmRzIGF0IG9yIGFmdGVyXG4gICAgICAgICAgICAvLyBBTkQgdGhleSBkb24ndCBoYXZlIGlkZW50aWNhbCB0aW1lIHNwYW5zXG4gICAgICAgICAgICBjb25zdCBzdGFydHNBdE9yQmVmb3JlID0gZS5zdGFydC5pc1NhbWVPckJlZm9yZShldmVudFN0YXJ0KTtcbiAgICAgICAgICAgIGNvbnN0IGVuZHNBdE9yQWZ0ZXIgPSBlLmVuZC5pc1NhbWVPckFmdGVyKGV2ZW50RW5kKTtcbiAgICAgICAgICAgIGNvbnN0IG5vdElkZW50aWNhbCA9ICEoZS5zdGFydC5pc1NhbWUoZXZlbnRTdGFydCkgJiYgZS5lbmQuaXNTYW1lKGV2ZW50RW5kKSk7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRzQXRPckJlZm9yZSAmJiBlbmRzQXRPckFmdGVyICYmIG5vdElkZW50aWNhbDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgZXZlbnQgY29udGFpbnMgb3RoZXIgZXZlbnRzXG4gICAgICAgICAgY29uc3QgaGFzQ29udGFpbmVkRXZlbnRzID0gZXZlbnRzV2l0aENvbHVtbnMuc29tZShlID0+IHtcbiAgICAgICAgICAgIGlmIChlLmV2ZW50LmlkID09PSBldmVudC5pZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgLy8gVGhpcyBldmVudCBtdXN0IHN0YXJ0IGF0IG9yIGJlZm9yZSB0aGUgb3RoZXIsIGFuZCBlbmQgYXQgb3IgYWZ0ZXIgdGhlIG90aGVyXG4gICAgICAgICAgICAvLyBBTkQgdGhleSBkb24ndCBoYXZlIGlkZW50aWNhbCB0aW1lIHNwYW5zXG4gICAgICAgICAgICBjb25zdCBzdGFydHNBdE9yQmVmb3JlID0gZXZlbnRTdGFydC5pc1NhbWVPckJlZm9yZShlLnN0YXJ0KTtcbiAgICAgICAgICAgIGNvbnN0IGVuZHNBdE9yQWZ0ZXIgPSBldmVudEVuZC5pc1NhbWVPckFmdGVyKGUuZW5kKTtcbiAgICAgICAgICAgIGNvbnN0IG5vdElkZW50aWNhbCA9ICEoZXZlbnRTdGFydC5pc1NhbWUoZS5zdGFydCkgJiYgZXZlbnRFbmQuaXNTYW1lKGUuZW5kKSk7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRzQXRPckJlZm9yZSAmJiBlbmRzQXRPckFmdGVyICYmIG5vdElkZW50aWNhbDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChpc0NvbnRhaW5lZEV2ZW50KSB7XG4gICAgICAgICAgICAvLyBDb250YWluZWQgZXZlbnQ6IHN0YXJ0cyB3aXRoIDEwJSBnYXAgZnJvbSBsZWZ0LCBleHRlbmRzIHRvIHJpZ2h0IGVkZ2VcbiAgICAgICAgICAgIGxlZnRQZXJjZW50ID0gMTA7XG4gICAgICAgICAgICB3aWR0aFBlcmNlbnQgPSA5MDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NvbnRhaW5lZEV2ZW50cykge1xuICAgICAgICAgICAgLy8gQ29udGFpbmVyIGV2ZW50OiBmdWxsIHdpZHRoXG4gICAgICAgICAgICBsZWZ0UGVyY2VudCA9IDA7XG4gICAgICAgICAgICB3aWR0aFBlcmNlbnQgPSAxMDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlZ3VsYXIgb3ZlcmxhcHBpbmcgZXZlbnRzOiBlcXVhbCBzcGxpdFxuICAgICAgICAgICAgY29uc3QgY29sdW1uV2lkdGggPSAxMDAgLyB0b3RhbENvbHVtbnM7XG4gICAgICAgICAgICBsZWZ0UGVyY2VudCA9IGNvbHVtbiAqIGNvbHVtbldpZHRoO1xuICAgICAgICAgICAgd2lkdGhQZXJjZW50ID0gY29sdW1uV2lkdGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gR2VuZXJhdGUgYSBzdGFibGUgY29sb3IgaW5kZXggZnJvbSBldmVudCBJRCBvciB1c2UgaW5kZXggYXMgZmFsbGJhY2tcbiAgICAgICAgICBsZXQgY29sb3JJbmRleCA9IGluZGV4ICUgY2FsZW5kYXJDb2xvcnMubGVuZ3RoO1xuICAgICAgICAgIGlmIChldmVudC5pZCkge1xuICAgICAgICAgICAgY29uc3QgbnVtZXJpY0lkID0gcGFyc2VJbnQoZXZlbnQuaWQpO1xuICAgICAgICAgICAgaWYgKCFpc05hTihudW1lcmljSWQpKSB7XG4gICAgICAgICAgICAgIGNvbG9ySW5kZXggPSBudW1lcmljSWQgJSBjYWxlbmRhckNvbG9ycy5sZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBGb3Igbm9uLW51bWVyaWMgSURzIChsaWtlIEdvb2dsZSBDYWxlbmRhciBJRHMpLCB1c2Ugc3RyaW5nIGhhc2hcbiAgICAgICAgICAgICAgbGV0IGhhc2ggPSAwO1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50LmlkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgZXZlbnQuaWQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICBoYXNoID0gaGFzaCAmIGhhc2g7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbG9ySW5kZXggPSBNYXRoLmFicyhoYXNoKSAlIGNhbGVuZGFyQ29sb3JzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY29sb3JzID0gY2FsZW5kYXJDb2xvcnNbY29sb3JJbmRleF07XG5cbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPFJlc2l6YWJsZUV2ZW50XG4gICAgICAgICAgICAgIGtleT17ZXZlbnQuaWR9XG4gICAgICAgICAgICAgIGV2ZW50PXtldmVudH1cbiAgICAgICAgICAgICAgZXZlbnRTdGFydD17ZXZlbnRTdGFydH1cbiAgICAgICAgICAgICAgZXZlbnRFbmQ9e2V2ZW50RW5kfVxuICAgICAgICAgICAgICBoZWlnaHQ9e2hlaWdodH1cbiAgICAgICAgICAgICAgdG9wT2Zmc2V0PXt0b3BPZmZzZXR9XG4gICAgICAgICAgICAgIGxlZnRQZXJjZW50PXtsZWZ0UGVyY2VudH1cbiAgICAgICAgICAgICAgd2lkdGhQZXJjZW50PXt3aWR0aFBlcmNlbnR9XG4gICAgICAgICAgICAgIGNvbG9ycz17Y29sb3JzfVxuICAgICAgICAgICAgICB6SW5kZXg9e2lzQ29udGFpbmVkRXZlbnQgPyAxMCA6IDV9XG4gICAgICAgICAgICAgIG9uQ2xpY2s9eyhlKSA9PiB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW0V2ZW50UmVuZGVyZXJdIE9wZW5pbmcgZXZlbnQgc3VtbWFyeSBmb3I6JywgZXZlbnQudGl0bGUpO1xuICAgICAgICAgICAgICAgIG9wZW5FdmVudFN1bW1hcnkoZXZlbnQpO1xuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApO1xuICAgICAgICB9KX1cbiAgICAgIDwvPlxuICAgICk7XG4gIH1cblxuICAvLyBNb250aCB2aWV3IC0ga2VlcCBleGlzdGluZyBsb2dpY1xuICBjb25zdCBmaWx0ZXJlZEV2ZW50cyA9IGV2ZW50cy5maWx0ZXIoKGV2ZW50OiBDYWxlbmRhckV2ZW50VHlwZSkgPT4ge1xuICAgIHJldHVybiBldmVudC5kYXRlLmZvcm1hdChcIkRELU1NLVlZXCIpID09PSBkYXRlLmZvcm1hdChcIkRELU1NLVlZXCIpO1xuICB9KTtcblxuICAvLyBEaXNwbGF5IG1heCAzIGV2ZW50c1xuICBjb25zdCBkaXNwbGF5RXZlbnRzID0gZmlsdGVyZWRFdmVudHMuc2xpY2UoMCwgMyk7XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAge2Rpc3BsYXlFdmVudHMubWFwKChldmVudCwgaW5kZXgpID0+IHtcbiAgICAgICAgLy8gR2VuZXJhdGUgYSBzdGFibGUgY29sb3IgaW5kZXggZnJvbSBldmVudCBJRCBvciB1c2UgaW5kZXggYXMgZmFsbGJhY2tcbiAgICAgICAgbGV0IGNvbG9ySW5kZXggPSBpbmRleCAlIGNhbGVuZGFyQ29sb3JzLmxlbmd0aDtcbiAgICAgICAgaWYgKGV2ZW50LmlkKSB7XG4gICAgICAgICAgY29uc3QgbnVtZXJpY0lkID0gcGFyc2VJbnQoZXZlbnQuaWQpO1xuICAgICAgICAgIGlmICghaXNOYU4obnVtZXJpY0lkKSkge1xuICAgICAgICAgICAgY29sb3JJbmRleCA9IG51bWVyaWNJZCAlIGNhbGVuZGFyQ29sb3JzLmxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRm9yIG5vbi1udW1lcmljIElEcyAobGlrZSBHb29nbGUgQ2FsZW5kYXIgSURzKSwgdXNlIHN0cmluZyBoYXNoXG4gICAgICAgICAgICBsZXQgaGFzaCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50LmlkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIGV2ZW50LmlkLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICAgIGhhc2ggPSBoYXNoICYgaGFzaDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2xvckluZGV4ID0gTWF0aC5hYnMoaGFzaCkgJSBjYWxlbmRhckNvbG9ycy5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbG9ycyA9IGNhbGVuZGFyQ29sb3JzW2NvbG9ySW5kZXhdO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAga2V5PXtldmVudC5pZH1cbiAgICAgICAgICAgIGRhdGEtZXZlbnQtaWQ9e2V2ZW50LmlkfVxuICAgICAgICAgICAgZHJhZ2dhYmxlPXt0cnVlfVxuICAgICAgICAgICAgb25EcmFnU3RhcnQ9eyhlKSA9PiB7XG4gICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgIGUuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSAnbW92ZSc7XG4gICAgICAgICAgICAgIGUuZGF0YVRyYW5zZmVyLnNldERhdGEoJ2FwcGxpY2F0aW9uL2pzb24nLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgZXZlbnRJZDogZXZlbnQuaWQsXG4gICAgICAgICAgICAgICAgZXZlbnREYXRlOiBldmVudC5kYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCBISDptbTpzcycpXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgZS5jdXJyZW50VGFyZ2V0LnN0eWxlLm9wYWNpdHkgPSAnMC41JztcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgICBvbkRyYWdFbmQ9eyhlKSA9PiB7XG4gICAgICAgICAgICAgIGUuY3VycmVudFRhcmdldC5zdHlsZS5vcGFjaXR5ID0gJzEnO1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIG9uQ2xpY2s9eyhlKSA9PiB7XG4gICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgIG9wZW5FdmVudFN1bW1hcnkoZXZlbnQpO1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImN1cnNvci1wb2ludGVyIHRyYW5zaXRpb24tYWxsXCJcbiAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgIGZvbnRTaXplOiAnMTJweCcsXG4gICAgICAgICAgICAgIHBhZGRpbmc6ICcycHggNnB4JyxcbiAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnNHB4JyxcbiAgICAgICAgICAgICAgd2hpdGVTcGFjZTogJ25vd3JhcCcsXG4gICAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgdGV4dE92ZXJmbG93OiAnZWxsaXBzaXMnLFxuICAgICAgICAgICAgICBmb250V2VpZ2h0OiA1MDAsXG4gICAgICAgICAgICAgIGxpbmVIZWlnaHQ6IDEuNCxcbiAgICAgICAgICAgICAgYmFja2dyb3VuZDogY29sb3JzLmJnLFxuICAgICAgICAgICAgICBjb2xvcjogY29sb3JzLmNvbG9yXG4gICAgICAgICAgICB9fVxuICAgICAgICAgICAgb25Nb3VzZUVudGVyPXsoZSkgPT4ge1xuICAgICAgICAgICAgICBlLmN1cnJlbnRUYXJnZXQuc3R5bGUub3BhY2l0eSA9ICcwLjgnO1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17KGUpID0+IHtcbiAgICAgICAgICAgICAgZS5jdXJyZW50VGFyZ2V0LnN0eWxlLm9wYWNpdHkgPSAnMSc7XG4gICAgICAgICAgICB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtldmVudC50aXRsZX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICAgIH0pfVxuICAgIDwvPlxuICApO1xufVxuIl0sIm5hbWVzIjpbInVzZUV2ZW50U3RvcmUiLCJkYXlqcyIsImlzU2FtZU9yQmVmb3JlIiwiaXNTYW1lT3JBZnRlciIsIlJlYWN0IiwiUmVzaXphYmxlRXZlbnQiLCJleHRlbmQiLCJFdmVudFJlbmRlcmVyIiwiZGF0ZSIsInZpZXciLCJldmVudHMiLCJleGNsdWRlQWxsRGF5Iiwib3BlbkV2ZW50U3VtbWFyeSIsInVwZGF0ZUV2ZW50IiwiY2FsZW5kYXJDb2xvcnMiLCJiZyIsImNvbG9yIiwiYWxsRGF5RXZlbnRzIiwiZmlsdGVyIiwiZXZlbnQiLCJmb3JtYXQiLCJldmVudEVuZCIsImVuZERhdGUiLCJhZGQiLCJkdXJhdGlvbkhvdXJzIiwiZGlmZiIsInN0YXJ0c0F0TWlkbmlnaHQiLCJob3VyIiwibWludXRlIiwiZXZlbnRzV2l0aExheW91dCIsIm1hcCIsImV2ZW50U3RhcnQiLCJzdGFydCIsImVuZCIsImNvbHVtbiIsInRvdGFsQ29sdW1ucyIsImlzQ29udGFpbmVkIiwic29ydCIsImEiLCJiIiwic3RhcnREaWZmIiwidmFsdWVPZiIsImZvckVhY2giLCJldmVudExheW91dCIsInNvbWUiLCJlIiwiaWQiLCJjb2x1bW5zIiwiY29udGFpbmVyRXZlbnQiLCJmaW5kIiwicHVzaCIsInBsYWNlZCIsImkiLCJsZW5ndGgiLCJjb2x1bW5FdmVudHMiLCJoYXNPdmVybGFwIiwiaXNCZWZvcmUiLCJpc0FmdGVyIiwibWF4Q29sdW1ucyIsIm92ZXJsYXBwaW5nRXZlbnRzIiwibWF4Q29sdW1uIiwiTWF0aCIsIm1heCIsImV2ZW50c1dpdGhDb2x1bW5zIiwiZXZlbnRzU3RhcnRpbmdJblRoaXNIb3VyIiwiaW5kZXgiLCJkdXJhdGlvbk1pbnV0ZXMiLCJoZWlnaHQiLCJtaW51dGVzRnJvbUhvdXJTdGFydCIsInRvcE9mZnNldCIsImxlZnRQZXJjZW50Iiwid2lkdGhQZXJjZW50IiwiaXNDb250YWluZWRFdmVudCIsInN0YXJ0c0F0T3JCZWZvcmUiLCJlbmRzQXRPckFmdGVyIiwibm90SWRlbnRpY2FsIiwiaXNTYW1lIiwiaGFzQ29udGFpbmVkRXZlbnRzIiwiY29sdW1uV2lkdGgiLCJjb2xvckluZGV4IiwibnVtZXJpY0lkIiwicGFyc2VJbnQiLCJpc05hTiIsImhhc2giLCJjaGFyQ29kZUF0IiwiYWJzIiwiY29sb3JzIiwiekluZGV4Iiwib25DbGljayIsInN0b3BQcm9wYWdhdGlvbiIsImNvbnNvbGUiLCJsb2ciLCJ0aXRsZSIsImZpbHRlcmVkRXZlbnRzIiwiZGlzcGxheUV2ZW50cyIsInNsaWNlIiwiZGl2IiwiZGF0YS1ldmVudC1pZCIsImRyYWdnYWJsZSIsIm9uRHJhZ1N0YXJ0IiwiZGF0YVRyYW5zZmVyIiwiZWZmZWN0QWxsb3dlZCIsInNldERhdGEiLCJKU09OIiwic3RyaW5naWZ5IiwiZXZlbnRJZCIsImV2ZW50RGF0ZSIsImN1cnJlbnRUYXJnZXQiLCJzdHlsZSIsIm9wYWNpdHkiLCJvbkRyYWdFbmQiLCJjbGFzc05hbWUiLCJmb250U2l6ZSIsInBhZGRpbmciLCJib3JkZXJSYWRpdXMiLCJ3aGl0ZVNwYWNlIiwib3ZlcmZsb3ciLCJ0ZXh0T3ZlcmZsb3ciLCJmb250V2VpZ2h0IiwibGluZUhlaWdodCIsImJhY2tncm91bmQiLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlTGVhdmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/event-renderer.tsx\n"));

/***/ })

});